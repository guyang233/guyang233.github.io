<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://guyang233.github.io</id>
    <title>Gridea</title>
    <updated>2020-03-25T16:55:38.141Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://guyang233.github.io"/>
    <link rel="self" href="https://guyang233.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://guyang233.github.io/images/avatar.png</logo>
    <icon>https://guyang233.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[IoC 之注册解析的 BeanDefinitions]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-jie-xi-zi-ding-yi-biao-qian</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-jie-xi-zi-ding-yi-biao-qian">
        </link>
        <updated>2020-03-25T15:11:52.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>DefaultBeanDefinitionDocumentReader的#processBeanDefinition方法，完成bean标签的解析的核心工作</li>
</ul>
<pre><code>/**
	 * Process the given bean element, parsing the bean definition
	 * and registering it with the registry.
	 */
	protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
		//进行Bean标签解析
		//如果解析成功，返回BeanDefinitionHolder对象，而BeanDefinitionHolder为name和alias的BeanDefinition 对象
		//若果解析失败，返回null
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
		if (bdHolder != null) {
			//进行自定义标签的解析
			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
			try {
				//进行BeanDefinition注册
				// Register the final decorated instance.
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
						bdHolder.getBeanName() + &quot;'&quot;, ele, ex);
			}
			//发出响应事件，通知相关的通知器，已完成对该Bean标签的解析
			// Send registration event.
			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
		}
	}
</code></pre>
<ul>
<li>解析工作分为三步
<ul>
<li>1、解析默认标签</li>
<li>2、解析默认标签后，解析自定义标签</li>
<li>3、注册解析后的BeanDefinition</li>
</ul>
</li>
<li>接下来的工作就是讲BeanDefinition进行注册</li>
</ul>
<h3 id="1-beandefinitionreaderutils">1、 BeanDefinitionReaderUtils</h3>
<ul>
<li>注册BeanDefinition，由BeanDefinitionReaderUtils.registerBeanDefinition方法完成</li>
</ul>
<pre><code>/**
	 * Register the given bean definition with the given bean factory.
	 * @param definitionHolder the bean definition including name and aliases
	 * @param registry the bean factory to register with
	 * @throws BeanDefinitionStoreException if registration failed
	 */
	public static void registerBeanDefinition(
			BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)
			throws BeanDefinitionStoreException {

		//注册beanName
		// Register bean definition under primary name.
		String beanName = definitionHolder.getBeanName();
		registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());

		//注册alias
		// Register aliases for bean name, if any.
		String[] aliases = definitionHolder.getAliases();
		if (aliases != null) {
			for (String alias : aliases) {
				registry.registerAlias(beanName, alias);
			}
		}
	}
</code></pre>
<ul>
<li>首先通过beanName注册BeanDefinition</li>
<li>然后通过注册别名alias和beanName的映射</li>
</ul>
<h3 id="2-beandefinitionregistry">2、BeanDefinitionRegistry</h3>
<ul>
<li>BeanDefinition的注册，由BeanDefinitionRegistry定义</li>
</ul>
<h4 id="21-通过beanname注册">2.1 通过BeanName注册</h4>
<pre><code>@Override
	public void registerBeanDefinition(String beanName, BeanDefinition beanDefinition)
			throws BeanDefinitionStoreException {

		//判断BeanName不为空
		Assert.hasText(beanName, &quot;Bean name must not be empty&quot;);
		//判断BeanDefinition不为null
		Assert.notNull(beanDefinition, &quot;BeanDefinition must not be null&quot;);

		//校验BeanDefinition
		if (beanDefinition instanceof AbstractBeanDefinition) {
			try {
				((AbstractBeanDefinition) beanDefinition).validate();
			}
			catch (BeanDefinitionValidationException ex) {
				throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,
						&quot;Validation of bean definition failed&quot;, ex);
			}
		}

		//从缓存中通BeanName获取BeanDefinition
		BeanDefinition existingDefinition = this.beanDefinitionMap.get(beanName);
		//如果BeanDefinition存在
		if (existingDefinition != null) {
			//判断是否允许覆盖，不允许的话直接抛出BeanDefinition覆盖异常
			if (!isAllowBeanDefinitionOverriding()) {
				throw new BeanDefinitionOverrideException(beanName, beanDefinition, existingDefinition);
			}
			//允许覆盖，判断已经存在的role和要注册的role的代销，小于的话打印info日志
			else if (existingDefinition.getRole() &lt; beanDefinition.getRole()) {
				// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE
				if (logger.isInfoEnabled()) {
					logger.info(&quot;Overriding user-defined bean definition for bean '&quot; + beanName +
							&quot;' with a framework-generated bean definition: replacing [&quot; +
							existingDefinition + &quot;] with [&quot; + beanDefinition + &quot;]&quot;);
				}
			}
			//允许覆盖，判断已经存在的role和要注册的role的代销，等于的话打印debug日志
			else if (!beanDefinition.equals(existingDefinition)) {
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Overriding bean definition for bean '&quot; + beanName +
							&quot;' with a different definition: replacing [&quot; + existingDefinition +
							&quot;] with [&quot; + beanDefinition + &quot;]&quot;);
				}
			}
			//其他，打印debug日志
			else {
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Overriding bean definition for bean '&quot; + beanName +
							&quot;' with an equivalent definition: replacing [&quot; + existingDefinition +
							&quot;] with [&quot; + beanDefinition + &quot;]&quot;);
				}
			}
			//允许覆盖，直接覆盖原有的BeanDefinition到beanDefinitionMap中
			this.beanDefinitionMap.put(beanName, beanDefinition);
		}
		//如果不存在
		else {
			//检测创建Bean阶段是否已经开启，如果开启了需要对beanDefinition进行并发控制
			if (hasBeanCreationStarted()) {
				// Cannot modify startup-time collection elements anymore (for stable iteration)
				synchronized (this.beanDefinitionMap) {
					//beanDefinitionMap为全局变量，避免并发情况
					//将beanName和BeanDefinition放入beanDefinitionMap中
					this.beanDefinitionMap.put(beanName, beanDefinition);
					List&lt;String&gt; updatedDefinitions = new ArrayList&lt;&gt;(this.beanDefinitionNames.size() + 1);
					updatedDefinitions.addAll(this.beanDefinitionNames);
					updatedDefinitions.add(beanName);
					this.beanDefinitionNames = updatedDefinitions;
					//从manualSingletonNames 中移除beanName
					removeManualSingletonName(beanName);
				}
			}
			else {
				// Still in startup registration phase
				//添加BeanDefinition到BeanDefinitionMap中
				this.beanDefinitionMap.put(beanName, beanDefinition);
				this.beanDefinitionNames.add(beanName);
				//从manualSingletonNames 中移除beanName
				removeManualSingletonName(beanName);
			}
			this.frozenBeanDefinitionNames = null;
		}

		//重新设置BeanName对应的缓存
		if (existingDefinition != null || containsSingleton(beanName)) {
			resetBeanDefinition(beanName);
		}
	}
</code></pre>
<ul>
<li>首先判断beanName和BeanDefinition不为空</li>
<li>然后对BeanDefinition进行校验。该校验也是注册过程中的最后一次校验了，主要是对BeanDefinition的methodOverrides属性进行校验</li>
<li>根据BeanName从缓存中获取BeanDefinition</li>
<li>缓存中存在，判断是否允许覆盖，不允许覆盖直接抛出异常，允许的话直接覆盖</li>
<li>若缓存中没有指定BeanName的BeanDefinition，则判断当前是否已经开始了Bean的创建阶段，如果是的话，需要对BeanDefinitionMap进行加锁并发控制，否则直接设置就行</li>
<li>若缓存中存在该BeanName或者单例Bean集合中存在该BeanName，则调用方法来进行清除缓存</li>
<li>核心就是将beanName和对应的BeanDefinition存放进beanDefinitionMap中，key是beanName，value是BeanDefinition</li>
</ul>
<h4 id="22-注册alias和beanname的映射">2.2 注册alias和beanName的映射</h4>
<pre><code>@Override
	public void registerAlias(String name, String alias) {
		//校验name 和 alias
		Assert.hasText(name, &quot;'name' must not be empty&quot;);
		Assert.hasText(alias, &quot;'alias' must not be empty&quot;);
		synchronized (this.aliasMap) {
			//name == alias去掉alias
			if (alias.equals(name)) {
				this.aliasMap.remove(alias);
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Alias definition '&quot; + alias + &quot;' ignored since it points to same name&quot;);
				}
			}
			else {
				String registeredName = this.aliasMap.get(alias);
				//已经存在
				if (registeredName != null) {
					//相同，则return 无需重复注册
					if (registeredName.equals(name)) {
						// An existing alias - no need to re-register
						return;
					}
					//是否允许覆盖
					if (!allowAliasOverriding()) {
						//不允许覆盖直接抛出浴场
						throw new IllegalStateException(&quot;Cannot define alias '&quot; + alias + &quot;' for name '&quot; +
								name + &quot;': It is already registered for name '&quot; + registeredName + &quot;'.&quot;);
					}
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Overriding alias '&quot; + alias + &quot;' definition for registered name '&quot; +
								registeredName + &quot;' with new target name '&quot; + name + &quot;'&quot;);
					}
				}
				//校验，是否循环指向
				checkForAliasCircle(name, alias);
				//注册alias
				this.aliasMap.put(alias, name);
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Alias definition '&quot; + alias + &quot;' registered for name '&quot; + name + &quot;'&quot;);
				}
			}
		}
	}
</code></pre>
<ul>
<li>注册alias和注册beanName差不多。</li>
<li>调用的#checkForAliasCircle方法来进行循环检测</li>
</ul>
<pre><code>/**
	 * Check whether the given name points back to the given alias as an alias
	 * in the other direction already, catching a circular reference upfront
	 * and throwing a corresponding IllegalStateException.
	 * @param name the candidate name
	 * @param alias the candidate alias
	 * @see #registerAlias
	 * @see #hasAlias
	 */
	protected void checkForAliasCircle(String name, String alias) {
		if (hasAlias(alias, name)) {
			throw new IllegalStateException(&quot;Cannot register alias '&quot; + alias +
					&quot;' for name '&quot; + name + &quot;': Circular reference - '&quot; +
					name + &quot;' is a direct or indirect alias for '&quot; + alias + &quot;' already&quot;);
		}
	}


/**
	 * Determine whether the given name has the given alias registered.
	 * @param name the name to check
	 * @param alias the alias to look for
	 * @since 4.2.1
	 */
	public boolean hasAlias(String name, String alias) {
		for (Map.Entry&lt;String, String&gt; entry : this.aliasMap.entrySet()) {
			String registeredName = entry.getValue();
			if (registeredName.equals(name)) {
				String registeredAlias = entry.getKey();
				if (registeredAlias.equals(alias) || hasAlias(registeredAlias, alias)) {
					return true;
				}
			}
		}
		return false;
	}

</code></pre>
<p>-如果name、alias分别为1、 3 , 则构成（1， 3）的映射。假如，此时集合中存在（A,1）和（3，A）的映射，意味着出现循环指向的情况。抛出异常</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC 之解析 <bean> 标签：解析自定义标签]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-jie-xi-lessbeangreater-biao-qian-jie-xi-zi-ding-yi-biao-qian</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-jie-xi-lessbeangreater-biao-qian-jie-xi-zi-ding-yi-biao-qian">
        </link>
        <updated>2020-03-25T14:57:08.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>解析Bean标签的过程
<ul>
<li>首先调用#parseBeanDefinitionElement方法来进行<bean>标签的解析</li>
<li>如果解析成功（返回bdHolder != null），调用#decorateBeanDefinitionIfRequired方法，完成自定义标签元素的解析</li>
</ul>
</li>
</ul>
<h3 id="1-decoratebeandefinitionifrequired">1. decorateBeanDefinitionIfRequired</h3>
<pre><code>/**
	 * Decorate the given bean definition through a namespace handler, if applicable.
	 * @param ele the current element
	 * @param originalDef the current bean definition
	 * @param containingBd the containing bean definition (if any)
	 * @return the decorated bean definition
	 */
	public BeanDefinitionHolder decorateBeanDefinitionIfRequired(
			Element ele, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {

		BeanDefinitionHolder finalDefinition = originalDef;

		//遍历属性，查看是否有适用于装饰的属性
		// Decorate based on custom attributes first.
		NamedNodeMap attributes = ele.getAttributes();
		for (int i = 0; i &lt; attributes.getLength(); i++) {
			Node node = attributes.item(i);
			finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);
		}

		//遍历子节点，查看是否有适用于修饰的子节点
		// Decorate based on custom nested elements.
		NodeList children = ele.getChildNodes();
		for (int i = 0; i &lt; children.getLength(); i++) {
			Node node = children.item(i);
			if (node.getNodeType() == Node.ELEMENT_NODE) {
				finalDefinition = decorateIfRequired(node, finalDefinition, containingBd);
			}
		}
		return finalDefinition;
	}
</code></pre>
<ul>
<li>都是遍历，前者遍历的是属性（attributes），后者遍历的是子节点（childNodes）。最终调用的都是#decorateIfRequired方法，装饰对应的节点（Node）</li>
</ul>
<h3 id="2-decorateifrequired">2. decorateIfRequired</h3>
<ul>
<li>#decorateIfRequired方法，装饰对应的节点（node）</li>
</ul>
<pre><code>/**
	 * Decorate the given bean definition through a namespace handler,
	 * if applicable.
	 * @param node the current child node
	 * @param originalDef the current bean definition
	 * @param containingBd the containing bean definition (if any)
	 * @return the decorated bean definition
	 */
	public BeanDefinitionHolder decorateIfRequired(
			Node node, BeanDefinitionHolder originalDef, @Nullable BeanDefinition containingBd) {

		//获取自定义命名的空间
		String namespaceUri = getNamespaceURI(node);
		//过滤掉默认命名的标签
		if (namespaceUri != null &amp;&amp; !isDefaultNamespace(namespaceUri)) {
			//获取相应的处理器
			NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);
			if (handler != null) {
				//进行装饰处理
				BeanDefinitionHolder decorated =
						handler.decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd));
				if (decorated != null) {
					return decorated;
				}
			}
			else if (namespaceUri.startsWith(&quot;http://www.springframework.org/schema/&quot;)) {
				error(&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;, node);
			}
			else {
				// A custom namespace, not to be handled by Spring - maybe &quot;xml:...&quot;.
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;No Spring NamespaceHandler found for XML schema namespace [&quot; + namespaceUri + &quot;]&quot;);
				}
			}
		}
		return originalDef;
	}
</code></pre>
<ul>
<li>首先获取自定义标签的命名空间</li>
<li>如果不是默认的命名空间，根据该命名空间获取相应的处理器</li>
<li>如果处理器存在，则进行装饰处理</li>
</ul>
<h3 id="3-小结">3. 小结</h3>
<ul>
<li>解析BeanDefinition的 入口在DefaultBeanDefinitionDocumentReader的#parseBeanDefinitions方法。该方法会根据命令空间来判断标签是默认标签还是自定义标签。其中
<ul>
<li>默认标签：由#parseDefaultElement方法来进行实现解析</li>
<li>自定义标签：由BeanDefinitionParserDelegate的#parseCustomElement来实现解析</li>
</ul>
</li>
<li>默认的标签中，会根据标签的名称的不同进行import、alias、bean、beans四大标签进行处理。其中bean标签的解析为核心，它由#processBeanDefinition方法来实现解析
<ul>
<li>processBeanDefinition方法，开始进入解析核心工作，分为三步
<ul>
<li>1、解析默认标签的默认标签，BeanDefinitionParserDelegate#parseBeanDefinitionElement方法，该方法会依次解析<bean>标签的属性、各个子元素，解析完成之后返回一个GenericBeanDefinition 实例对象</li>
<li>2、解析默认标签下面的自定义标签BeanDefinitionParserDelegate#decorateBeanDefinitionIfRequired方法</li>
<li>3、注册解析的BeanDefinition， #doRegisterBeanDefinitions方法</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC 之解析 <bean> 标签：constructor-arg、property、qualifier]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-jie-xi-lessbeangreater-biao-qian-constructor-argpropertyqualifier</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-jie-xi-lessbeangreater-biao-qian-constructor-argpropertyqualifier">
        </link>
        <updated>2020-03-23T15:05:04.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1constructor-arg">1.constructor-arg</h3>
<pre><code>public class StudentService {

    private String name;

    private Integer age;

    private BookService bookService;

    StudentService(String name, Integer age, BookService bookService){

        this.name = name;

        this.age = age;

        this.bookService = bookService;

    }

}


&lt;bean id=&quot;bookService&quot; class=&quot;org.springframework.core.service.BookService&quot;/&gt;

&lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.service.StudentService&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; value=&quot;chenssy&quot;/&gt;
    &lt;constructor-arg name=&quot;age&quot; value=&quot;100&quot;/&gt;
    &lt;constructor-arg name=&quot;bookService&quot; ref=&quot;bookService&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>StudentService 定义一个构造函数，配置文件中使用constructor-arg元素对其配置，该元素可以实现对StudentService自动寻找构造函数，并在初始化的时候将值作为参数进行设置</li>
</ul>
<h4 id="12-parseconstructorargelements">1.2 parseConstructorArgElements</h4>
<ul>
<li>调用#parseConstructorArgElements方法来对constructor-arg元素进行解析</li>
</ul>
<pre><code>	/**
	 * Parse constructor-arg sub-elements of the given bean element.
	 */
	public void parseConstructorArgElements(Element beanEle, BeanDefinition bd) {
		NodeList nl = beanEle.getChildNodes();
		for (int i = 0; i &lt; nl.getLength(); i++) {
			Node node = nl.item(i);
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, CONSTRUCTOR_ARG_ELEMENT)) {
				parseConstructorArgElement((Element) node, bd);
			}
		}
	}

</code></pre>
<ul>
<li>遍历所有的子元素，如果子元素为constructor-arg， 则调用parseConstructorArgElement方法进行解析</li>
</ul>
<h4 id="13-parseconstructorargelement">1.3 parseConstructorArgElement</h4>
<pre><code>/**
	 * Parse a constructor-arg element.
	 */
	public void parseConstructorArgElement(Element ele, BeanDefinition bd) {
		//提取index、type、name的属性值
		String indexAttr = ele.getAttribute(INDEX_ATTRIBUTE);
		String typeAttr = ele.getAttribute(TYPE_ATTRIBUTE);
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
		//如果有index
		if (StringUtils.hasLength(indexAttr)) {
			try {
				int index = Integer.parseInt(indexAttr);
				if (index &lt; 0) {
					error(&quot;'index' cannot be lower than 0&quot;, ele);
				}
				else {
					try {
						this.parseState.push(new ConstructorArgumentEntry(index));
						//解析ele对应的属性元素
						Object value = parsePropertyValue(ele, bd, null);
						//根据解析的元素属性，构造一个ValueHolder对象
						ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
						if (StringUtils.hasLength(typeAttr)) {
							valueHolder.setType(typeAttr);
						}
						if (StringUtils.hasLength(nameAttr)) {
							valueHolder.setName(nameAttr);
						}
						valueHolder.setSource(extractSource(ele));
						//不允许重复指定相同参数
						if (bd.getConstructorArgumentValues().hasIndexedArgumentValue(index)) {
							error(&quot;Ambiguous constructor-arg entries for index &quot; + index, ele);
						}
						else {
							bd.getConstructorArgumentValues().addIndexedArgumentValue(index, valueHolder);
						}
					}
					finally {
						this.parseState.pop();
					}
				}
			}
			catch (NumberFormatException ex) {
				error(&quot;Attribute 'index' of tag 'constructor-arg' must be an integer&quot;, ele);
			}
		}
		else {
			try {
				this.parseState.push(new ConstructorArgumentEntry());
				Object value = parsePropertyValue(ele, bd, null);
				ConstructorArgumentValues.ValueHolder valueHolder = new ConstructorArgumentValues.ValueHolder(value);
				if (StringUtils.hasLength(typeAttr)) {
					valueHolder.setType(typeAttr);
				}
				if (StringUtils.hasLength(nameAttr)) {
					valueHolder.setName(nameAttr);
				}
				valueHolder.setSource(extractSource(ele));
				bd.getConstructorArgumentValues().addGenericArgumentValue(valueHolder);
			}
			finally {
				this.parseState.pop();
			}
		}
	}
</code></pre>
<ul>
<li>
<p>首先获取index、type、name三个属性值。然后根据是否存在index来区分。执行后续逻辑。其实两者逻辑都差不多</p>
<ul>
<li>构造ConstructorArgumentEntry对象，放入ParseState队列中。ConstructorArgumentEntry表示构造函数的参数</li>
<li>调用#parsePropertyValue方法来解析标签元素，返回属性值</li>
<li>构造ValueHolder对象，设置type和name</li>
<li>最后将ValueHolder对象添加到indexedArgumentValues集合中</li>
</ul>
</li>
<li>
<p>无index的逻辑和有index 的处理逻辑差不多，只是有几点不同</p>
<ul>
<li>无index的ConstructorArgumentEntry对象调用的是无参函数</li>
<li>最后将GenericArgumentValues集合中</li>
</ul>
</li>
</ul>
<h4 id="14-parsepropertyvalue">1.4 parsePropertyValue</h4>
<pre><code>/**
	 * Get the value of a property element. May be a list etc.
	 * Also used for constructor arguments, &quot;propertyName&quot; being null in this case.
	 */
	@Nullable
	public Object parsePropertyValue(Element ele, BeanDefinition bd, @Nullable String propertyName) {
		String elementName = (propertyName != null ?
				&quot;&lt;property&gt; element for property '&quot; + propertyName + &quot;'&quot; :
				&quot;&lt;constructor-arg&gt; element&quot;);

		//查找子节点中是否含ref、value、list等元素
		// Should only have one child element: ref, value, list, etc.
		NodeList nl = ele.getChildNodes();
		Element subElement = null;
		for (int i = 0; i &lt; nl.getLength(); i++) {
			Node node = nl.item(i);
			//跳过description和meta标签
			if (node instanceof Element &amp;&amp; !nodeNameEquals(node, DESCRIPTION_ELEMENT) &amp;&amp;
					!nodeNameEquals(node, META_ELEMENT)) {
				// Child element is what we're looking for.
				if (subElement != null) {
					error(elementName + &quot; must not contain more than one sub-element&quot;, ele);
				}
				else {
					subElement = (Element) node;
				}
			}
		}
		//是否有ref属性
		boolean hasRefAttribute = ele.hasAttribute(REF_ATTRIBUTE);
		//是否有value属性
		boolean hasValueAttribute = ele.hasAttribute(VALUE_ATTRIBUTE);
		//同时存在，发生冲突
		if ((hasRefAttribute &amp;&amp; hasValueAttribute) ||
				((hasRefAttribute || hasValueAttribute) &amp;&amp; subElement != null)) {
			error(elementName +
					&quot; is only allowed to contain either 'ref' attribute OR 'value' attribute OR sub-element&quot;, ele);
		}

		//将ref属性值构造为RuntimeBeanReference对象
		if (hasRefAttribute) {
			String refName = ele.getAttribute(REF_ATTRIBUTE);
			if (!StringUtils.hasText(refName)) {
				error(elementName + &quot; contains empty 'ref' attribute&quot;, ele);
			}
			RuntimeBeanReference ref = new RuntimeBeanReference(refName);
			ref.setSource(extractSource(ele));
			return ref;
		}
		//将value属性值构造为TypedStringValue对象
		else if (hasValueAttribute) {
			TypedStringValue valueHolder = new TypedStringValue(ele.getAttribute(VALUE_ATTRIBUTE));
			valueHolder.setSource(extractSource(ele));
			return valueHolder;
		}
		//解析子元素
		else if (subElement != null) {
			return parsePropertySubElement(subElement, bd);
		}
		else {
			// Neither child element nor &quot;ref&quot; or &quot;value&quot; attribute found.
			error(elementName + &quot; must specify a ref or value&quot;, ele);
			return null;
		}
	}

</code></pre>
<ul>
<li>提取constructor-arg元素的子元素，ref属性值、value属性值，对其进行判断，以下两种情况是不允许存在的
<ul>
<li>ref属性值和value属性值时同时存在的</li>
<li>存在ref或value并且有子元素存在</li>
</ul>
</li>
<li>如果存在ref属性值，构造为 RuntimeBeanReference实例对象</li>
<li>如果存在value属性值，构造为TypedStringValue 实例对象</li>
<li>如果子元素不为空，调用#parsePropertySubElement方法来解析子元素</li>
</ul>
<h4 id="15-parsepropertysubelement">1.5 parsePropertySubElement</h4>
<ul>
<li>如果constructor-arg中有子元素，调用#parsePropertySubElement方法来进行解析</li>
</ul>
<pre><code>	/**
	 * Parse a value, ref or collection sub-element of a property or
	 * constructor-arg element.
	 * @param ele subelement of property element; we don't know which yet
	 * @param bd the current bean definition (if any)
	 * @param defaultValueType the default type (class name) for any
	 * {@code &lt;value&gt;} tag that might be created
	 */
	@Nullable
	public Object parsePropertySubElement(Element ele, @Nullable BeanDefinition bd, @Nullable String defaultValueType) {
		if (!isDefaultNamespace(ele)) {
			return parseNestedCustomElement(ele, bd);
		}
		else if (nodeNameEquals(ele, BEAN_ELEMENT)) {
			BeanDefinitionHolder nestedBd = parseBeanDefinitionElement(ele, bd);
			if (nestedBd != null) {
				nestedBd = decorateBeanDefinitionIfRequired(ele, nestedBd, bd);
			}
			return nestedBd;
		}
		else if (nodeNameEquals(ele, REF_ELEMENT)) {
			// A generic reference to any name of any bean.
			String refName = ele.getAttribute(BEAN_REF_ATTRIBUTE);
			boolean toParent = false;
			if (!StringUtils.hasLength(refName)) {
				// A reference to the id of another bean in a parent context.
				refName = ele.getAttribute(PARENT_REF_ATTRIBUTE);
				toParent = true;
				if (!StringUtils.hasLength(refName)) {
					error(&quot;'bean' or 'parent' is required for &lt;ref&gt; element&quot;, ele);
					return null;
				}
			}
			if (!StringUtils.hasText(refName)) {
				error(&quot;&lt;ref&gt; element contains empty target attribute&quot;, ele);
				return null;
			}
			RuntimeBeanReference ref = new RuntimeBeanReference(refName, toParent);
			ref.setSource(extractSource(ele));
			return ref;
		}
		else if (nodeNameEquals(ele, IDREF_ELEMENT)) {
			return parseIdRefElement(ele);
		}
		else if (nodeNameEquals(ele, VALUE_ELEMENT)) {
			return parseValueElement(ele, defaultValueType);
		}
		else if (nodeNameEquals(ele, NULL_ELEMENT)) {
			// It's a distinguished null value. Let's wrap it in a TypedStringValue
			// object in order to preserve the source location.
			TypedStringValue nullHolder = new TypedStringValue(null);
			nullHolder.setSource(extractSource(ele));
			return nullHolder;
		}
		else if (nodeNameEquals(ele, ARRAY_ELEMENT)) {
			return parseArrayElement(ele, bd);
		}
		else if (nodeNameEquals(ele, LIST_ELEMENT)) {
			return parseListElement(ele, bd);
		}
		else if (nodeNameEquals(ele, SET_ELEMENT)) {
			return parseSetElement(ele, bd);
		}
		else if (nodeNameEquals(ele, MAP_ELEMENT)) {
			return parseMapElement(ele, bd);
		}
		else if (nodeNameEquals(ele, PROPS_ELEMENT)) {
			return parsePropsElement(ele);
		}
		else {
			error(&quot;Unknown property sub-element: [&quot; + ele.getNodeName() + &quot;]&quot;, ele);
			return null;
		}
	}
</code></pre>
<h3 id="2-property元素">2. property元素</h3>
<h4 id="21-实例">2.1 实例</h4>
<pre><code>&lt;bean id=&quot;studentService&quot; class=&quot;org.springframework.core.service.StudentService&quot;&gt;
    &lt;property name=&quot;name&quot; value=&quot;chenssy&quot;/&gt;
    &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<h4 id="22-parsepropertyelements">2.2 parsePropertyElements</h4>
<ul>
<li>对于property子元素的解析，调用parsePropertyElements方法</li>
</ul>
<pre><code>/**
	 * Parse property sub-elements of the given bean element.
	 */
	public void parsePropertyElements(Element beanEle, BeanDefinition bd) {
		NodeList nl = beanEle.getChildNodes();
		for (int i = 0; i &lt; nl.getLength(); i++) {
			Node node = nl.item(i);
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, PROPERTY_ELEMENT)) {
				parsePropertyElement((Element) node, bd);
			}
		}
	}
</code></pre>
<ul>
<li>遍历提取所有property的子元素，然后调用#parsePropertyElement进行解析</li>
</ul>
<pre><code>/**
	 * Parse a property element.
	 */
	public void parsePropertyElement(Element ele, BeanDefinition bd) {
		//获取name属性值
		String propertyName = ele.getAttribute(NAME_ATTRIBUTE);
		if (!StringUtils.hasLength(propertyName)) {
			error(&quot;Tag 'property' must have a 'name' attribute&quot;, ele);
			return;
		}
		this.parseState.push(new PropertyEntry(propertyName));
		try {
			//如果存在相同的name，报错
			if (bd.getPropertyValues().contains(propertyName)) {
				error(&quot;Multiple 'property' definitions for property '&quot; + propertyName + &quot;'&quot;, ele);
				return;
			}
			//解析属性值
			Object val = parsePropertyValue(ele, bd, propertyName);
			//构造PropertyValue实例对象
			PropertyValue pv = new PropertyValue(propertyName, val);
			//解析meta标签
			parseMetaElements(ele, pv);
			pv.setSource(extractSource(ele));
			//设置到PropertyValues集合中
			bd.getPropertyValues().addPropertyValue(pv);
		}
		finally {
			this.parseState.pop();
		}
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC 之解析 <bean> 标签：meta、lookup-method、replace-method]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-jie-xi-lessbeangreater-biao-qian-metalookup-methodreplace-method</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-jie-xi-lessbeangreater-biao-qian-metalookup-methodreplace-method">
        </link>
        <updated>2020-03-23T13:59:51.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>解析Bean标签的基本属性之后，会依次调用BeanDefinitionParserDelegate的#parseMetaElements、#parseLookupOverrideSubElements、#parseReplacedMethodSubElements三个方法，分别对meta、lookup-method、replace-method元素进行解析。三个元素的作用如下
<ul>
<li>meta：元数据</li>
<li>lookup-method：Spring动态改变bean里方法的实现，方法执行返回的对象，使用Spring内原有的这类对象替换，通过改变方法返回值来动态改变方法、内部实现使用cglib方法，重新生成子类，重写配置的方法和返回对象，达到动态改变的效果</li>
<li>replace-method：Spring动态改变Bean里方法的实现，需要改变的方法，使用Spring内原有其他类（需要继承接口org.springframework.beans.factory.support.MethodReplacer）的逻辑，替换这个方法。通过改变方法执行逻辑来实现动态的改变方法</li>
</ul>
</li>
</ul>
<h3 id="1mate子元素">1.Mate子元素</h3>
<ul>
<li>Meta：元数据。当需要使用里面的信息时可以通过key获取</li>
<li>meta所声明的key并不会在Bean中提现，只是一个额外的声明，当我们需要使用里面的信息时，通过调用BeanDefinition的#getAttribute方法来获取。子元素的解析过程：</li>
</ul>
<pre><code>/**
	 * Parse the meta elements underneath the given element, if any.
	 */
	public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {
		NodeList nl = ele.getChildNodes();
		//遍历子节点
		for (int i = 0; i &lt; nl.getLength(); i++) {
			Node node = nl.item(i);
			//&lt;meta key=&quot;special-data&quot; value=&quot;sprecial stragey&quot; /&gt;
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) {
				Element metaElement = (Element) node;
				String key = metaElement.getAttribute(KEY_ATTRIBUTE);
				String value = metaElement.getAttribute(VALUE_ATTRIBUTE);
				BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);
				attribute.setSource(extractSource(metaElement));
				attributeAccessor.addMetadataAttribute(attribute);
			}
		}
	}
</code></pre>
<ul>
<li>解析过程比较简单，获取响应的key-value构建BeanMetadataAttribute对象，然后attributeAccessor.addMetadataAttribute(attribute);</li>
</ul>
<pre><code>AbstractBeanDefinition 继承 BeanMetadataAttributeAccessor 类
BeanMetadataAttributeAccessor 继承 AttributeAccessorSupport 类。
</code></pre>
<h4 id="11-addmetadataattribute">1.1 addMetadataAttribute</h4>
<ul>
<li>调用BeanMetadataAttributeAccessor#addMetadataAttribute方法将BeanMetadataAttribute设置到BeanMetadataAttributeAccessor中</li>
</ul>
<pre><code>	/**
	 * Add the given BeanMetadataAttribute to this accessor's set of attributes.
	 * @param attribute the BeanMetadataAttribute object to register
	 */
	public void addMetadataAttribute(BeanMetadataAttribute attribute) {
		super.setAttribute(attribute.getName(), attribute);
	}

</code></pre>
<ul>
<li>委托给父类AttributeAccessorSupport实现</li>
</ul>
<pre><code>	@Override
	public void setAttribute(String name, @Nullable Object value) {
		Assert.notNull(name, &quot;Name must not be null&quot;);
		if (value != null) {
			this.attributes.put(name, value);
		}
		else {
			removeAttribute(name);
		}
	}
</code></pre>
<ul>
<li>AttributeAccessorSupport是AttributeAccessor的实现者，AttributeAccessor接口定义了与其他对象的元数据进行连接和访问的约定，可以通过该接口对属性进行获取、设置和删除的操作</li>
</ul>
<h4 id="12-getattribute">1.2 getAttribute</h4>
<ul>
<li>设置元数据之后，可以通过BeanDefinition的#getAttribute来获取属性</li>
</ul>
<pre><code>	/** Map with String keys and Object values. */
	private final Map&lt;String, Object&gt; attributes = new LinkedHashMap&lt;&gt;();


@Override
	@Nullable
	public Object getAttribute(String name) {
		Assert.notNull(name, &quot;Name must not be null&quot;);
		return this.attributes.get(name);
	}
</code></pre>
<h3 id="2lookup-method子元素">2.lookup-method子元素</h3>
<ul>
<li>lookup-method：获取器注入，是把一个方法声明为某种类型的bean但是实际要返回的bean是在配置文件里面配置的。该方法可以设计一些可插拔的功能上，解除程序的依赖</li>
</ul>
<pre><code>public interface Car {

    void display();

}

public class Bmw implements Car{

    @Override
    public void display() {
        System.out.println(&quot;我是 BMW&quot;);
    }

}

public class Hongqi implements Car{

    @Override
    public void display() {
        System.out.println(&quot;我是 hongqi&quot;);
    }

}

public abstract class Display {

    public void display(){
        getCar().display();
    }
    
    public abstract Car getCar();

}

public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);
    Display display = (Display) context.getBean(&quot;display&quot;);
    display.display();
}


-- xml配置内容

&lt;bean id=&quot;display&quot; class=&quot;org.springframework.core.test1.Display&quot;&gt;
    &lt;lookup-method name=&quot;getCar&quot; bean=&quot;hongqi&quot;/&gt;
&lt;/bean&gt;
</code></pre>
<ul>
<li>运行结果为</li>
</ul>
<pre><code>我是 hongqi

</code></pre>
<ul>
<li>如果将bean的内容替换为bmw，运行结果为</li>
</ul>
<pre><code>我是 BMW

</code></pre>
<h4 id="21-parselookupoverridesubelements">2.1 parseLookupOverrideSubElements</h4>
<ul>
<li>上面的示例已经初步了解了lookup-method子元素提供的功能呢，其解析通过#parseLookupOverrideSubElements方法</li>
</ul>
<pre><code>	/**
	 * Parse lookup-override sub-elements of the given bean element.
	 */
	public void parseLookupOverrideSubElements(Element beanEle, MethodOverrides overrides) {
		NodeList nl = beanEle.getChildNodes();
		//遍历子节点
		for (int i = 0; i &lt; nl.getLength(); i++) {
			Node node = nl.item(i);
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, LOOKUP_METHOD_ELEMENT)) {
				Element ele = (Element) node;
				String methodName = ele.getAttribute(NAME_ATTRIBUTE);
				String beanRef = ele.getAttribute(BEAN_ELEMENT);
				LookupOverride override = new LookupOverride(methodName, beanRef);
				//添加到MethodOverrides中
				override.setSource(extractSource(ele));
				overrides.addOverride(override);
			}
		}
	}
</code></pre>
<ul>
<li>解析过程和meta标签的过程差不多，同样是解析name、bean来构造一个LookupOverride对象，然后添加到MethodOverrides中</li>
</ul>
<h3 id="3replace-method子元素">3.replace-method子元素</h3>
<ul>
<li>replace-method：可以在运行时调用新的方法替换现有的方法，还能动态的更新原有方法的逻辑</li>
</ul>
<pre><code>public class Method {

    public void display(){
        System.out.println(&quot;我是原始方法&quot;);
    }

}

public class MethodReplace implements MethodReplacer {

    @Override
    public Object reimplement(Object obj, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;我是替换方法&quot;);
        return null;
    }

}

public static void main(String[] args) {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:spring.xml&quot;);
    Method method = (Method) context.getBean(&quot;method&quot;);
    method.display();
}

-- xml文件
&lt;bean id=&quot;methodReplace&quot; class=&quot;org.springframework.core.test1.MethodReplace&quot;/&gt;

&lt;bean id=&quot;method&quot; class=&quot;org.springframework.core.test1.Method&quot;/&gt;
</code></pre>
<ul>
<li>运行结果为</li>
</ul>
<pre><code>我是原始方法
</code></pre>
<ul>
<li>增加replace-method子元素</li>
</ul>
<pre><code>&lt;bean id=&quot;methodReplace&quot; class=&quot;org.springframework.core.test1.MethodReplace&quot;/&gt;

&lt;bean id=&quot;method&quot; class=&quot;org.springframework.core.test1.Method&quot;&gt;

    &lt;replaced-method name=&quot;display&quot; replacer=&quot;methodReplace&quot;/&gt;

&lt;/bean&gt;
</code></pre>
<ul>
<li>运行结果为</li>
</ul>
<pre><code>我是替换方法

</code></pre>
<h4 id="31-parsereplacedmethodsubelements">3.1 parseReplacedMethodSubElements</h4>
<ul>
<li>上面的示例展示了replace-method标签的作用，是调用#parseReplacedMethodSubElements方法来解析replace-method标签的</li>
</ul>
<pre><code>	/**
	 * Parse replaced-method sub-elements of the given bean element.
	 */
	public void parseReplacedMethodSubElements(Element beanEle, MethodOverrides overrides) {
		NodeList nl = beanEle.getChildNodes();
		//遍历子节点
		for (int i = 0; i &lt; nl.getLength(); i++) {
			Node node = nl.item(i);
			if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, REPLACED_METHOD_ELEMENT)) {
				Element replacedMethodEle = (Element) node;
				String name = replacedMethodEle.getAttribute(NAME_ATTRIBUTE);
				String callback = replacedMethodEle.getAttribute(REPLACER_ATTRIBUTE);
				ReplaceOverride replaceOverride = new ReplaceOverride(name, callback);
				// Look for arg-type match elements.
				List&lt;Element&gt; argTypeEles = DomUtils.getChildElementsByTagName(replacedMethodEle, ARG_TYPE_ELEMENT);
				for (Element argTypeEle : argTypeEles) {
					String match = argTypeEle.getAttribute(ARG_TYPE_MATCH_ATTRIBUTE);
					match = (StringUtils.hasText(match) ? match : DomUtils.getTextValue(argTypeEle));
					if (StringUtils.hasText(match)) {
						replaceOverride.addTypeIdentifier(match);
					}
				}
				replaceOverride.setSource(extractSource(replacedMethodEle));
				overrides.addOverride(replaceOverride);
			}
		}
	}
</code></pre>
<h3 id="4总结">4.总结</h3>
<ul>
<li>主要是说明了lookup-method和replace-method两个子元素标签的作用以及解析</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC 之解析 <bean> 标签：BeanDefinition]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-jie-xi-lessbeangreater-biao-qian-beandefinition</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-jie-xi-lessbeangreater-biao-qian-beandefinition">
        </link>
        <updated>2020-03-22T07:09:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-beandefinition">1、BeanDefinition</h3>
<ul>
<li>是一个接口，描述定义了Bean实例的定义，包括属性值、构造方法值和继承自它的类的更多信息</li>
</ul>
<pre><code>String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;
String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;


int ROLE_APPLICATION = 0;
int ROLE_SUPPORT = 1;
int ROLE_INFRASTRUCTURE = 2;

void setParentName(@Nullable String parentName);
@Nullable
String getParentName();

void setBeanClassName(@Nullable String beanClassName);
@Nullable
String getBeanClassName();

void setScope(@Nullable String scope);
@Nullable
String getScope();

void setLazyInit(boolean lazyInit);
boolean isLazyInit();

void setDependsOn(@Nullable String... dependsOn);
@Nullable
String[] getDependsOn();

void setAutowireCandidate(boolean autowireCandidate);
boolean isAutowireCandidate();

void setPrimary(boolean primary);
boolean isPrimary();

void setFactoryBeanName(@Nullable String factoryBeanName);
@Nullable
String getFactoryBeanName();

void setFactoryMethodName(@Nullable String factoryMethodName);
@Nullable
String getFactoryMethodName();

ConstructorArgumentValues getConstructorArgumentValues();
default boolean hasConstructorArgumentValues() {
	return !getConstructorArgumentValues().isEmpty();
}

MutablePropertyValues getPropertyValues();
default boolean hasPropertyValues() {
	return !getPropertyValues().isEmpty();
}

void setInitMethodName(@Nullable String initMethodName);
@Nullable
String getInitMethodName();

void setDestroyMethodName(@Nullable String destroyMethodName);
@Nullable
String getDestroyMethodName();

void setRole(int role);
int getRole();

void setDescription(@Nullable String description);
@Nullable
String getDescription();

boolean isSingleton();

boolean isPrototype();

boolean isAbstract();

@Nullable
String getResourceDescription();

@Nullable
BeanDefinition getOriginatingBeanDefinition();
</code></pre>
<h4 id="1-1-beandefinition的父关系">1、1 BeanDefinition的父关系</h4>
<ul>
<li>BeanDefinition继承了AttributeAccessor接口。定义了与其他对象的（元数据）进行连接和访问的约定，即对书香的修改，包括获取、设置、删除</li>
</ul>
<pre><code>/**
 * Interface defining a generic contract for attaching and accessing metadata
 * to/from arbitrary objects.
 *
 * @author Rob Harrop
 * @since 2.0
 */
public interface AttributeAccessor {

	/**
	 * Set the attribute defined by {@code name} to the supplied {@code value}.
	 * If {@code value} is {@code null}, the attribute is {@link #removeAttribute removed}.
	 * &lt;p&gt;In general, users should take care to prevent overlaps with other
	 * metadata attributes by using fully-qualified names, perhaps using
	 * class or package names as prefix.
	 * @param name the unique attribute key
	 * @param value the attribute value to be attached
	 */
	void setAttribute(String name, @Nullable Object value);

	/**
	 * Get the value of the attribute identified by {@code name}.
	 * Return {@code null} if the attribute doesn't exist.
	 * @param name the unique attribute key
	 * @return the current value of the attribute, if any
	 */
	@Nullable
	Object getAttribute(String name);

	/**
	 * Remove the attribute identified by {@code name} and return its value.
	 * Return {@code null} if no attribute under {@code name} is found.
	 * @param name the unique attribute key
	 * @return the last value of the attribute, if any
	 */
	@Nullable
	Object removeAttribute(String name);

	/**
	 * Return {@code true} if the attribute identified by {@code name} exists.
	 * Otherwise return {@code false}.
	 * @param name the unique attribute key
	 */
	boolean hasAttribute(String name);

	/**
	 * Return the names of all attributes.
	 */
	String[] attributeNames();

}
</code></pre>
<ul>
<li>BeanMetadataElement接口，Bean元对象持有的配置元素可以通过#getSource获取</li>
</ul>
<pre><code>/**
 * Interface to be implemented by bean metadata elements
 * that carry a configuration source object.
 *
 * @author Juergen Hoeller
 * @since 2.0
 */
public interface BeanMetadataElement {

	/**
	 * Return the configuration source {@code Object} for this metadata element
	 * (may be {@code null}).
	 */
	@Nullable
	default Object getSource() {
		return null;
	}

}
</code></pre>
<h4 id="1-2beandefinition的子关系">1、2BeanDefinition的子关系</h4>
<figure data-type="image" tabindex="1"><img src="https://guyang233.github.io/post-images/1584861940380.png" alt="" loading="lazy"></figure>
<ul>
<li>我们常用的三个实现类有
<ul>
<li>org.springframework.beans.factory.support.ChildBeanDefinition</li>
<li>org.springframework.beans.factory.support.RootBeanDefinition</li>
<li>org.springframework.beans.factory.support.GenericBeanDefinition</li>
<li>三者都继承自AbstractBeanDefinition, AbstractBeanDefinition对三个子类的共同属性抽象</li>
<li>如果配置文件中定义了父<bean>和子<bean>，则父bean用RootBeanDefinition表示，子bean用ChildBeanDefinition表示，没有父bean的就使用RootBeanDefinition表示</li>
<li>GenericBeanDefinition是一站式服务类</li>
</ul>
</li>
</ul>
<h3 id="2-解析bean标签">2、解析Bean标签</h3>
<h4 id="2-1-createbeandefinition">2、1 createBeanDefinition</h4>
<pre><code>	/**
	 * Create a bean definition for the given class name and parent name.
	 * @param className the name of the bean class
	 * @param parentName the name of the bean's parent bean
	 * @return the newly created bean definition
	 * @throws ClassNotFoundException if bean class resolution was attempted but failed
	 */
	protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)
			throws ClassNotFoundException {

		return BeanDefinitionReaderUtils.createBeanDefinition(
				parentName, className, this.readerContext.getBeanClassLoader());
	}

    	/**
    * 主要是创建GenericBeanDefinition对象，设置parentName，BeanClass，ClassName属性
	 * Create a new GenericBeanDefinition for the given parent name and class name,
	 * eagerly loading the bean class if a ClassLoader has been specified.
	 * @param parentName the name of the parent bean, if any
	 * @param className the name of the bean class, if any
	 * @param classLoader the ClassLoader to use for loading bean classes
	 * (can be {@code null} to just register bean classes by name)
	 * @return the bean definition
	 * @throws ClassNotFoundException if the bean class could not be loaded
	 */
	public static AbstractBeanDefinition createBeanDefinition(
			@Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException {
		//创建GenericBeanDefinition对象
		GenericBeanDefinition bd = new GenericBeanDefinition();
		//设置parentName
		bd.setParentName(parentName);
		if (className != null) {
			if (classLoader != null) {
				//设置BeanClass
				bd.setBeanClass(ClassUtils.forName(className, classLoader));
			}
			else {
				//设置BeanName
				bd.setBeanClassName(className);
			}
		}
		return bd;
	}
</code></pre>
<h4 id="22-parsebeandefinitionattributes">2.2 parseBeanDefinitionAttributes</h4>
<ul>
<li>对Bean标签进行解析</li>
</ul>
<pre><code>	/**
	 * Apply the attributes of the given bean element to the given bean * definition.
	 * @param ele bean declaration element
	 * @param beanName bean name
	 * @param containingBean containing bean definition
	 * @return a bean definition initialized according to the bean element attributes
	 */
	public AbstractBeanDefinition parseBeanDefinitionAttributes(Element ele, String beanName,
			@Nullable BeanDefinition containingBean, AbstractBeanDefinition bd) {
		//解析scope属性
		if (ele.hasAttribute(SINGLETON_ATTRIBUTE)) {
			error(&quot;Old 1.x 'singleton' attribute in use - upgrade to 'scope' declaration&quot;, ele);
		}
		else if (ele.hasAttribute(SCOPE_ATTRIBUTE)) {
			bd.setScope(ele.getAttribute(SCOPE_ATTRIBUTE));
		}
		else if (containingBean != null) {
			// Take default from containing bean in case of an inner bean definition.
			bd.setScope(containingBean.getScope());
		}
		//解析abstract 属性
		if (ele.hasAttribute(ABSTRACT_ATTRIBUTE)) {
			bd.setAbstract(TRUE_VALUE.equals(ele.getAttribute(ABSTRACT_ATTRIBUTE)));
		}
		//解析lazy-init
		String lazyInit = ele.getAttribute(LAZY_INIT_ATTRIBUTE);
		if (isDefaultValue(lazyInit)) {
			lazyInit = this.defaults.getLazyInit();
		}
		bd.setLazyInit(TRUE_VALUE.equals(lazyInit));
		//解析auto-wire属性
		String autowire = ele.getAttribute(AUTOWIRE_ATTRIBUTE);
		bd.setAutowireMode(getAutowireMode(autowire));
		//解析depends-on属性
		if (ele.hasAttribute(DEPENDS_ON_ATTRIBUTE)) {
			String dependsOn = ele.getAttribute(DEPENDS_ON_ATTRIBUTE);
			bd.setDependsOn(StringUtils.tokenizeToStringArray(dependsOn, MULTI_VALUE_ATTRIBUTE_DELIMITERS));
		}
		// 解析 autowire-candidate 属性
		String autowireCandidate = ele.getAttribute(AUTOWIRE_CANDIDATE_ATTRIBUTE);
		if (isDefaultValue(autowireCandidate)) {
			String candidatePattern = this.defaults.getAutowireCandidates();
			if (candidatePattern != null) {
				String[] patterns = StringUtils.commaDelimitedListToStringArray(candidatePattern);
				bd.setAutowireCandidate(PatternMatchUtils.simpleMatch(patterns, beanName));
			}
		}
		else {
			bd.setAutowireCandidate(TRUE_VALUE.equals(autowireCandidate));
		}
		//解析primary属性
		if (ele.hasAttribute(PRIMARY_ATTRIBUTE)) {
			bd.setPrimary(TRUE_VALUE.equals(ele.getAttribute(PRIMARY_ATTRIBUTE)));
		}
		//解析init-method属性
		if (ele.hasAttribute(INIT_METHOD_ATTRIBUTE)) {
			String initMethodName = ele.getAttribute(INIT_METHOD_ATTRIBUTE);
			bd.setInitMethodName(initMethodName);
		}
		else if (this.defaults.getInitMethod() != null) {
			bd.setInitMethodName(this.defaults.getInitMethod());
			bd.setEnforceInitMethod(false);
		}
		//解析destory-method属性
		if (ele.hasAttribute(DESTROY_METHOD_ATTRIBUTE)) {
			String destroyMethodName = ele.getAttribute(DESTROY_METHOD_ATTRIBUTE);
			bd.setDestroyMethodName(destroyMethodName);
		}
		else if (this.defaults.getDestroyMethod() != null) {
			bd.setDestroyMethodName(this.defaults.getDestroyMethod());
			bd.setEnforceDestroyMethod(false);
		}
		//解析factory-method属性
		if (ele.hasAttribute(FACTORY_METHOD_ATTRIBUTE)) {
			bd.setFactoryMethodName(ele.getAttribute(FACTORY_METHOD_ATTRIBUTE));
		}
		if (ele.hasAttribute(FACTORY_BEAN_ATTRIBUTE)) {
			bd.setFactoryBeanName(ele.getAttribute(FACTORY_BEAN_ATTRIBUTE));
		}

		return bd;
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC 之解析 <bean> 标签：开启解析进程]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-jie-xi-lessbeangreater-biao-qian-kai-qi-jie-xi-jin-cheng</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-jie-xi-lessbeangreater-biao-qian-kai-qi-jie-xi-jin-cheng">
        </link>
        <updated>2020-03-22T06:46:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-processbeandefinition">1、processBeanDefinition</h3>
<ul>
<li>解析bean标签</li>
</ul>
<pre><code>/**
	 * Process the given bean element, parsing the bean definition
	 * and registering it with the registry.
	 */
	protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
		//进行Bean标签解析
		//如果解析成功，返回BeanDefinitionHolder对象，而BeanDefinitionHolder为name和alias的BeanDefinition 对象
		//若果解析失败，返回null
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
		if (bdHolder != null) {
			//进行自定义标签的解析
			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
			try {
				//进行BeanDefinition注册
				// Register the final decorated instance.
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
						bdHolder.getBeanName() + &quot;'&quot;, ele, ex);
			}
			//发出响应事件，通知相关的通知器，已完成对该Bean标签的解析
			// Send registration event.
			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
		}
	}
</code></pre>
<ul>
<li>步骤解析
<ul>
<li>调用#parseBeanDefinitionElement方法来对标签进行解析
<ul>
<li>解析成功，返回BeanDefinitionHolder对象</li>
<li>解析失败，返回null</li>
</ul>
</li>
<li>如果BeanDefinitionHolder实例不为null， 调用#decorateBeanDefinitionIfRequired方法对自定义标签进行解析</li>
<li>解析完成之后，调用BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());来进行Bean注册</li>
<li>最后发出相应事件，通知相关的监听器，完成Bean标签的解析</li>
</ul>
</li>
</ul>
<h3 id="2-parsebeandefinitionelement">2、parseBeanDefinitionElement</h3>
<pre><code>	/**
	 * Parses the supplied {@code &lt;bean&gt;} element. May return {@code null}
	 * if there were errors during parse. Errors are reported to the
	 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
	 */
	@Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
		return parseBeanDefinitionElement(ele, null);
	}


    	/**
	 * Parses the supplied {@code &lt;bean&gt;} element. May return {@code null}
	 * if there were errors during parse. Errors are reported to the
	 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
	 */
	@Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
		//解析id和name
		String id = ele.getAttribute(ID_ATTRIBUTE);
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
		//计算别名集合
		List&lt;String&gt; aliases = new ArrayList&lt;&gt;();
		if (StringUtils.hasLength(nameAttr)) {
			String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
			aliases.addAll(Arrays.asList(nameArr));
		}
		//优先使用BeanName
		String beanName = id;
		//其次使用别名集合中的第一个
		if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {
			//移除别名集合
			beanName = aliases.remove(0);
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName +
						&quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;);
			}
		}
		//检查BeanName的唯一性
		if (containingBean == null) {
			checkNameUniqueness(beanName, aliases, ele);
		}
		//解析属性，构造AbstractBeanDefinition对象
		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
		if (beanDefinition != null) {
			//beanName为空。使用BeanName生成规则
			if (!StringUtils.hasText(beanName)) {
				try {
					if (containingBean != null) {
						//生成唯一的BeanName
						beanName = BeanDefinitionReaderUtils.generateBeanName(
								beanDefinition, this.readerContext.getRegistry(), true);
					}
					else {
						//生成唯一的BeanName
						beanName = this.readerContext.generateBeanName(beanDefinition);
						// Register an alias for the plain bean class name, if still possible,
						// if the generator returned the class name plus a suffix.
						// This is expected for Spring 1.2/2.0 backwards compatibility.
						String beanClassName = beanDefinition.getBeanClassName();
						if (beanClassName != null &amp;&amp;
								beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;
								!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
							aliases.add(beanClassName);
						}
					}
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; +
								&quot;using generated bean name [&quot; + beanName + &quot;]&quot;);
					}
				}
				catch (Exception ex) {
					error(ex.getMessage(), ele);
					return null;
				}
			}
			//创建返回BeanDefinitionHolder对象
			String[] aliasesArray = StringUtils.toStringArray(aliases);
			return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
		}

		return null;
	}
</code></pre>
<ul>
<li>这个方法还没有对Bean标签进行解析，只是在解析动作之前做了一些功能架构，主要的工作有
<ul>
<li>解析id、name属性，确定alias结合</li>
<li>检测BeanName是否唯一</li>
</ul>
</li>
<li>BeanName的命名规则
<ul>
<li>id不为空， BeanName就是id</li>
<li>id为空，BeanName就是别名集合中第一个元素</li>
<li>如果两者都为空，那么根据规则来设置生成BeanName。</li>
</ul>
</li>
<li>#parseBeanDefinitionElement，对属性进行解析</li>
<li>根据所获取的信息（beanName， alias，BeanDefinition构造BeanDefinitionHolder对象</li>
<li>检查BeanName唯一性的代码</li>
</ul>
<pre><code>/**
	 * Validate that the specified bean name and aliases have not been used already
	 * within the current level of beans element nesting.
	 */
	protected void checkNameUniqueness(String beanName, List&lt;String&gt; aliases, Element beanElement) {
		//寻找是否已经使用过BeanName
		String foundName = null;
		//先去已经使用过名字的集合中查找
		if (StringUtils.hasText(beanName) &amp;&amp; this.usedNames.contains(beanName)) {
			foundName = beanName;
		}
		//已经使用过名字的集合中查找匹配的别名
		if (foundName == null) {
			foundName = CollectionUtils.findFirstMatch(this.usedNames, aliases);
		}
		if (foundName != null) {
			error(&quot;Bean name '&quot; + foundName + &quot;' is already used in this &lt;beans&gt; element&quot;, beanElement);
		}
		//没有的话。把BeanName和别名集合添加进去
		this.usedNames.add(beanName);
		this.usedNames.addAll(aliases);
	}
</code></pre>
<ul>
<li>BeanDefinitionHolder的简化代码</li>
</ul>
<pre><code>/**
 * BeanDefinition 对象
 */
private final BeanDefinition beanDefinition;
/**
 * Bean 名字
 */
private final String beanName;
/**
 * 别名集合
 */
@Nullable
private final String[] aliases;
</code></pre>
<h4 id="2-1-parsebeandefinitionelement">2、1 parseBeanDefinitionElement</h4>
<ul>
<li>对属性进行解析并且封装为AbstractBeanDefinition</li>
</ul>
<pre><code>/**
	 * Parse the bean definition itself, without regard to name or aliases. May return
	 * {@code null} if problems occurred during the parsing of the bean definition.
	 */
		@Nullable
	public AbstractBeanDefinition parseBeanDefinitionElement(
			Element ele, String beanName, @Nullable BeanDefinition containingBean) {

		this.parseState.push(new BeanEntry(beanName));
		//解析class属性
		String className = null;
		if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
			className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
		}
		//解析parent属性
		String parent = null;
		if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
			parent = ele.getAttribute(PARENT_ATTRIBUTE);
		}

		try {
			//创建用于承载属性的AbstractBeanDefinition
			AbstractBeanDefinition bd = createBeanDefinition(className, parent);
			//默认解析Bean的各种属性
			parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
			//提取description
			bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));
			// tips：
			// 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，
			// 解析出来以后的信息都放到 bd 的属性中
			// 解析元数据 &lt;meta /&gt;
			parseMetaElements(ele, bd);
			// 解析 lookup-method 属性 &lt;lookup-method /&gt;
			parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
			// 解析 replaced-method 属性 &lt;replaced-method /&gt;
			parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

			// 解析构造函数参数 &lt;constructor-arg /&gt;
			parseConstructorArgElements(ele, bd);
			// 解析 property 子元素 &lt;property /&gt;
			parsePropertyElements(ele, bd);
			// 解析 qualifier 子元素 &lt;qualifier /&gt;
			parseQualifierElements(ele, bd);

			bd.setResource(this.readerContext.getResource());
			bd.setSource(extractSource(ele));

			return bd;
		}
		catch (ClassNotFoundException ex) {
			error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);
		}
		catch (NoClassDefFoundError err) {
			error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);
		}
		catch (Throwable ex) {
			error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);
		}
		finally {
			this.parseState.pop();
		}

		return null;
	}
</code></pre>
<h4 id="2-2-createbeandefinition">2、2 createBeanDefinition</h4>
<ul>
<li>创建AbstractBeanDefinition</li>
</ul>
<pre><code>/**
	 * Create a bean definition for the given class name and parent name.
	 * @param className the name of the bean class
	 * @param parentName the name of the bean's parent bean
	 * @return the newly created bean definition
	 * @throws ClassNotFoundException if bean class resolution was attempted but failed
	 */
	protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)
			throws ClassNotFoundException {

		return BeanDefinitionReaderUtils.createBeanDefinition(
				parentName, className, this.readerContext.getBeanClassLoader());
	}

    /**
	 * Create a new GenericBeanDefinition for the given parent name and class name,
	 * eagerly loading the bean class if a ClassLoader has been specified.
	 * @param parentName the name of the parent bean, if any
	 * @param className the name of the bean class, if any
	 * @param classLoader the ClassLoader to use for loading bean classes
	 * (can be {@code null} to just register bean classes by name)
	 * @return the bean definition
	 * @throws ClassNotFoundException if the bean class could not be loaded
	 */
	public static AbstractBeanDefinition createBeanDefinition(
			@Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException {

		GenericBeanDefinition bd = new GenericBeanDefinition();
		bd.setParentName(parentName);
		if (className != null) {
			if (classLoader != null) {
				bd.setBeanClass(ClassUtils.forName(className, classLoader));
			}
			else {
				bd.setBeanClassName(className);
			}
		}
		return bd;
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC 之解析 Bean：解析 import 标签]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-jie-xi-beanjie-xi-import-biao-qian</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-jie-xi-beanjie-xi-import-biao-qian">
        </link>
        <updated>2020-03-16T14:33:30.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>根节点或者子节点采用默认的命名空间的话，采用#parseDefaultElement解析</li>
<li>如果没有采用默认空间命名的话，采用#parseCustomElement解析</li>
<li>默认解析的代码如下：</li>
</ul>
<pre><code>public static final String IMPORT_ELEMENT = &quot;import&quot;;

public static final String ALIAS_ELEMENT = &quot;alias&quot;;

public static final String BEAN_ELEMENT = BeanDefinitionParserDelegate.BEAN_ELEMENT;

public static final String BEAN_ELEMENT = &quot;bean&quot;;

public static final String NESTED_BEANS_ELEMENT = &quot;beans&quot;;

private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
		//解析默认标签import
		if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
			importBeanDefinitionResource(ele);
		}
		//解析默认标签alias
		else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
			processAliasRegistration(ele);
		}
		//解析默认标签bean
		else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
			processBeanDefinition(ele, delegate);
		}
		//解析默认标签beans
		else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
			// recurse
			doRegisterBeanDefinitions(ele);
		}
	}
</code></pre>
<h4 id="1-import示例">1、 import示例</h4>
<ul>
<li>避免过多的配置文件，Spring提供import配置文件的方式</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;import resource=&quot;spring-student.xml&quot;/&gt;

    &lt;import resource=&quot;spring-student-dtd.xml&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>spring.xml配置文件中，使用import标签的方式导入其他模块的配置文件，简化了配置文件维护的复杂度，便于管理
<ul>
<li>如果有配置需要修改直接修改对应的配置文件即可</li>
<li>若有新的配置文件需要被引入的话，直接添加import引入即可</li>
</ul>
</li>
</ul>
<h4 id="2-importbeandefinitionresource">2、 importBeanDefinitionResource</h4>
<ul>
<li>Spring调用#importBeanDefinitionResource方法来对import标签进行解析</li>
</ul>
<pre><code>/**
	 * Parse an &quot;import&quot; element and load the bean definitions
	 * from the given resource into the bean factory.
	 */
	protected void importBeanDefinitionResource(Element ele) {
		//获取Resource 的值
		String location = ele.getAttribute(RESOURCE_ATTRIBUTE);
		//为空，直接退出
		if (!StringUtils.hasText(location)) {
			getReaderContext().error(&quot;Resource location must not be empty&quot;, ele);
			return;
		}
		//解析系统属性，格式如:&quot;${user.dir}&quot;
		// Resolve system properties: e.g. &quot;${user.dir}&quot;
		location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);
		//实际Resource的集合，即import的地址，有哪些Resource资源
		Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;&gt;(4);

		//判断location是相对路径还是绝对路径
		// Discover whether the location is an absolute or relative URI
		boolean absoluteLocation = false;
		try {
			absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();
		}
		catch (URISyntaxException ex) {
			// cannot convert to an URI, considering the location relative
			// unless it is the well-known Spring prefix &quot;classpath*:&quot;
		}

		// Absolute or relative?
		//绝对路径
		if (absoluteLocation) {
			try {
				//添加配置文件地址的Resource到actualResources中，并且加载对应的BeanDefinition
				int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from URL location [&quot; + location + &quot;]&quot;);
				}
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(
						&quot;Failed to import bean definitions from URL location [&quot; + location + &quot;]&quot;, ele, ex);
			}
		}
		//相对路径
		else {
			// No URL -&gt; considering resource location as relative to the current file.
			try {
				int importCount;
				//创建相对路径的Resource
				Resource relativeResource = getReaderContext().getResource().createRelative(location);
				if (relativeResource.exists()) {
					//加载relativeResource对应的BeanDefinition
					importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);
					//添加到actualResources中
					actualResources.add(relativeResource);
				}
				//不存在
				else {
					//获取根路径地址
					String baseLocation = getReaderContext().getResource().getURL().toString();
					//添加配置文件地址的 Resource 到 actualResources 中，并加载相应的 BeanDefinition 们
					importCount = getReaderContext().getReader().loadBeanDefinitions(
							StringUtils.applyRelativePath(baseLocation, location), actualResources);
				}
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from relative location [&quot; + location + &quot;]&quot;);
				}
			}
			catch (IOException ex) {
				getReaderContext().error(&quot;Failed to resolve current resource location&quot;, ele, ex);
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(
						&quot;Failed to import bean definitions from relative location [&quot; + location + &quot;]&quot;, ele, ex);
			}
		}
		//解析成功后，进行监听器激活处理
		Resource[] actResArray = actualResources.toArray(new Resource[0]);
		getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));
	}
</code></pre>
<ul>
<li>解析import的流程
<ul>
<li>获取Resource的值，值表示对应的资源的路径
<ul>
<li>解析路径中的系统属性，例如“${user.dir}”</li>
</ul>
</li>
<li>判断是绝对路径还是相对路径
<ul>
<li>绝对路径，递归调用Bean的解析过程，进行另一次的解析</li>
<li>相对路径，计算出绝对路径得到Resource，然后进行解析</li>
</ul>
</li>
<li>通知监听器，解析完毕</li>
</ul>
</li>
</ul>
<h5 id="21-判断路径">2.1 判断路径</h5>
<pre><code>	absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();
</code></pre>
<ul>
<li>判断绝对路径的规则如下：
<ul>
<li>以classpath*：或者classpath：开头的为绝对路径</li>
<li>能够通过该location构建出java.net.URL的为绝对路径</li>
<li>根据location构造java.net.URI判断调用#isAbsolute方法，判断是否是绝对路径</li>
</ul>
</li>
</ul>
<h5 id="22-处理绝对路径">2.2 处理绝对路径</h5>
<ul>
<li>如果location是绝对路径的话，调用#loadBeanDefinitions方法</li>
</ul>
<pre><code>/**
	 * Load bean definitions from the specified resource location.
	 * &lt;p&gt;The location can also be a location pattern, provided that the
	 * ResourceLoader of this bean definition reader is a ResourcePatternResolver.
	 * @param location the resource location, to be loaded with the ResourceLoader
	 * (or ResourcePatternResolver) of this bean definition reader
	 * @param actualResources a Set to be filled with the actual Resource objects
	 * that have been resolved during the loading process. May be {@code null}
	 * to indicate that the caller is not interested in those Resource objects.
	 * @return the number of bean definitions found
	 * @throws BeanDefinitionStoreException in case of loading or parsing errors
	 * @see #getResourceLoader()
	 * @see #loadBeanDefinitions(org.springframework.core.io.Resource)
	 * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])
	 */
	public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException {
		//获取ResourceLoader对象
		ResourceLoader resourceLoader = getResourceLoader();
		if (resourceLoader == null) {
			throw new BeanDefinitionStoreException(
					&quot;Cannot load bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;);
		}

		if (resourceLoader instanceof ResourcePatternResolver) {
			// Resource pattern matching available.
			try {
				//获取Resource数组，因为可能有多个Resource
				Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
				//加载BeanDefinition
				int count = loadBeanDefinitions(resources);
				if (actualResources != null) {
					Collections.addAll(actualResources, resources);
				}
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;);
				}
				return count;
			}
			catch (IOException ex) {
				throw new BeanDefinitionStoreException(
						&quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);
			}
		}
		else {
			//获取Resource对象
			// Can only load single resources by absolute URL.
			Resource resource = resourceLoader.getResource(location);
			//加载BeanDefinition
			int count = loadBeanDefinitions(resource);
			if (actualResources != null) {
				actualResources.add(resource);
			}
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location [&quot; + location + &quot;]&quot;);
			}
			return count;
		}
	}
</code></pre>
<ul>
<li>整体逻辑
<ul>
<li>获取ResourceLoader对象</li>
<li>根据不同的ResourceLoader执行的逻辑不同，主要是有可能存在多个Resources</li>
<li>然后调用#loadBeanDefinitions方法，所以这是一个递归的过程</li>
<li>例外获取的Resource对象或者数组都会添加到actualResources</li>
</ul>
</li>
</ul>
<h5 id="23-处理相对路径">2.3 处理相对路径</h5>
<ul>
<li>若果location是相对路径，则会根据Resource计算出对应的相对路径的Resource对象，若该Resource对象存在，调用#loadBeanDefinitions方法进行加载</li>
<li>否则，构造一个绝对location，即StringUtils.applyRelativePath(baseLocation, location)，并且调用#loadBeanDefinitions方法，与绝对路径一样</li>
</ul>
<h4 id="3-小结">3、小结</h4>
<ul>
<li>import标签的解析比较明朗，获取Resource属性值，得到正确的资源路径，然后调用#loadBeanDefinitions进行递归的BeanDefinition加载</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC 之注册 BeanDefinitions]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-zhu-ce-beandefinitions</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-zhu-ce-beandefinitions">
        </link>
        <updated>2020-03-14T08:45:49.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>获取XML DOcument对象之后，会根据该对象和Resource资源对象调用XmlBeanDefinitionReader#registerBeanDefinitions方法，开始注册BeanDefinition。</li>
</ul>
<pre><code>	public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
		//创建BeanDefinitionDocumentReader对象
		BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
		//获取之前注册的数量
		int countBefore = getRegistry().getBeanDefinitionCount();
		//创建XmlReaderContext对象，注册BeanDefinition
		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
		//返回新注册的数量
		return getRegistry().getBeanDefinitionCount() - countBefore;
	}

</code></pre>
<ul>
<li>BeanDefinitionDocumentReader 定义读取Document并注册BeanDefinition功能</li>
</ul>
<h4 id="1-createbeandefinitiondocumentreader">1、createBeanDefinitionDocumentReader</h4>
<pre><code>	private Class&lt;? extends BeanDefinitionDocumentReader&gt; documentReaderClass =
			DefaultBeanDefinitionDocumentReader.class;

	protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {
		return BeanUtils.instantiateClass(this.documentReaderClass);
	}
</code></pre>
<h4 id="2-registerbeandefinitions">2、registerBeanDefinitions</h4>
<pre><code>public interface BeanDefinitionDocumentReader {

	/**
	 * Read bean definitions from the given DOM document and
	 * register them with the registry in the given reader context.
	 * @param doc the DOM document
	 * @param readerContext the current context of the reader
	 * (includes the target registry and the resource being parsed)
	 * @throws BeanDefinitionStoreException in case of parsing errors
	 */
	void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)
			throws BeanDefinitionStoreException;

}
</code></pre>
<ul>
<li>从给定的Document对象中解析定义的BeanDefinition并将他们注册到注册表中，方法接受两个参数：
<ul>
<li>doc， 方法参数，待解析的Document对象</li>
<li>readerContent方法，解析器的当前上下文，包括目标注册表和被解析的资源。它是根据 Resource 来创建的</li>
</ul>
</li>
</ul>
<h5 id="21-defaultbeandefinitiondocumentreader">2.1 DefaultBeanDefinitionDocumentReader</h5>
<ul>
<li>BeanDefinitionDocumentReader有且只有一个实现类，DefaultBeanDefinitionDocumentReader，对于registerBeanDefinitions的实现</li>
</ul>
<pre><code>	@Nullable
	private XmlReaderContext readerContext;

	@Nullable
	private BeanDefinitionParserDelegate delegate;

    	protected void doRegisterBeanDefinitions(Element root) {
		// Any nested &lt;beans&gt; elements will cause recursion in this method. In
		// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,
		// keep track of the current (parent) delegate, which may be null. Create
		// the new (child) delegate with a reference to the parent for fallback purposes,
		// then ultimately reset this.delegate back to its original (parent) reference.
		// this behavior emulates a stack of delegates without actually necessitating one.
		//记录之前的BeanDefinitionParserDelegate
		BeanDefinitionParserDelegate parent = this.delegate;
		//创建BeanDefinitionParserDelegate对象设置给delegate
		this.delegate = createDelegate(getReaderContext(), root, parent);
		//检查&lt;beans/&gt;跟标签的命名空间是否为空，或者是http://www.springframework.org/schema/beans
		if (this.delegate.isDefaultNamespace(root)) {
			//处理profile属性
			String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
			if (StringUtils.hasText(profileSpec)) {
				String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
						profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
				//所有的profile都无效，则不进行注册
				// We cannot use Profiles.of(...) since profile expressions are not supported
				// in XML config. See SPR-12458 for details.
				if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +
								&quot;] not matching: &quot; + getReaderContext().getResource());
					}
					return;
				}
			}
		}
		//解析钱处理
		preProcessXml(root);
		//解析
		parseBeanDefinitions(root, this.delegate);
		//解析后处理
		postProcessXml(root);
		//设置delegate回老的BeanDefinitionParserDelegate
		this.delegate = parent;
	}

</code></pre>
<ul>
<li>创建BeanDefinitionParserDelegate对象，并设置到delegate。BeanDefinitionParserDelegate是一个重要的类，负责解析BeanDefinition，定义解析XML Element的各种方法</li>
</ul>
<pre><code>protected BeanDefinitionParserDelegate createDelegate(
			XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) {
		//创建BeanDefinitionParserDelegate对象
		BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);
		//初始化默认
		delegate.initDefaults(root, parentDelegate);
		return delegate;
	}
</code></pre>
<ul>
<li>检查<beans/>根标签的命名空间是否为空，或者是http://www.springframework.org/schema/beans
<ul>
<li>判断是否<beans/>上配置了profile属性。</li>
<li>使用分隔符切分，可能有多个profile</li>
<li>判断如果所有的profile都无效，则return不进行注册</li>
</ul>
</li>
<li>调用#parseBeanDefinitions方法，进行逻辑解析</li>
<li>解析前后的处理。目前这两个方法的实现都是空的，交由子类来实现</li>
</ul>
<pre><code>protected void preProcessXml(Element root) {}

protected void postProcessXml(Element root) {}
</code></pre>
<h5 id="221-parsebeandefinitions">2.2.1 parseBeanDefinitions</h5>
<ul>
<li>#parseBeanDefinitions方法来进行BeanDefinition的逻辑解析</li>
<li>Spring的Bean有两种声明方式
<ul>
<li>配置文件式声明：<bean id="studentService" class="org.springframework.core.StudentService" /></li>
<li>自定义注解解析： <a href="tx:annotation-driven">tx:annotation-driven</a></li>
</ul>
</li>
</ul>
<pre><code>	protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
		//如果根节点使用默认的命名空间，执行默认的解析
		if (delegate.isDefaultNamespace(root)) {
			NodeList nl = root.getChildNodes();
			//遍历子节点
			for (int i = 0; i &lt; nl.getLength(); i++) {
				Node node = nl.item(i);
				if (node instanceof Element) {
					Element ele = (Element) node;
					//判断是否使用默认命名空间，执行默认解析Element
					if (delegate.isDefaultNamespace(ele)) {
						parseDefaultElement(ele, delegate);
					}
					else {
						//执行自定义解析
						delegate.parseCustomElement(ele);
					}
				}
			}
		}
		else {
			//根节点没有使用默认的命名空间的话，也执行自定义解析
			delegate.parseCustomElement(root);
		}
	}
</code></pre>
<ul>
<li>默认的命名空间，调用#parseDefaultElement来进行解析</li>
</ul>
<pre><code>private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
		if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
			importBeanDefinitionResource(ele);
		}
		else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
			processAliasRegistration(ele);
		}
		else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
			processBeanDefinition(ele, delegate);
		}
		else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
			// recurse
			doRegisterBeanDefinitions(ele);
		}
	}
</code></pre>
<ul>
<li>不是默认的命名空间，调用#parseCustomElement进行解析</li>
</ul>
<h5 id="3-createreadercontext">3、createReaderContext</h5>
<ul>
<li>createReaderContext代码如下</li>
</ul>
<pre><code>	/**
	 * Create the {@link XmlReaderContext} to pass over to the document reader.
	 */
	public XmlReaderContext createReaderContext(Resource resource) {
		return new XmlReaderContext(resource, this.problemReporter, this.eventListener,
				this.sourceExtractor, this, getNamespaceHandlerResolver());
	}
</code></pre>
<h5 id="4-小结">4、小结</h5>
<ul>
<li>doLoadBeanDefinitions中做的三件事情分析完毕（获取Document，验证模型，注册BeanDefinition）</li>
<li>doLoadBeanDefinitions方法的整体时序<br>
<img src="https://guyang233.github.io/post-images/1584201819026.jpg" alt="" loading="lazy"></li>
<li>红框的部分就是BeanDefinition的解析过程</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC 之获取 Document 对象]]></title>
        <id>https://guyang233.github.io/post/hah</id>
        <link href="https://guyang233.github.io/post/hah">
        </link>
        <updated>2020-03-09T14:46:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="获取document实例">获取Document实例</h3>
<h4 id="1-documentloader">1、 DocumentLoader</h4>
<ul>
<li>定义从资源文件加载到转换为Document的功能
<ul>
<li>InputSource，加载Document的resource资源</li>
<li>EntityResolver， 解析文件的解析器</li>
<li>ErrorHandler， 处理加载Document对象的过程中的异常</li>
<li>validationMode， 校验模式</li>
<li>namespaceAware，命名空间，如果需要提供支持对XML名称空间的支持，则需要值为true</li>
</ul>
</li>
</ul>
<pre><code>public interface DocumentLoader {

	/**
	 * Load a {@link Document document} from the supplied {@link InputSource source}.
	 * @param inputSource the source of the document that is to be loaded
	 * @param entityResolver the resolver that is to be used to resolve any entities
	 * @param errorHandler used to report any errors during document loading
	 * @param validationMode the type of validation
	 * {@link org.springframework.util.xml.XmlValidationModeDetector#VALIDATION_DTD DTD}
	 * or {@link org.springframework.util.xml.XmlValidationModeDetector#VALIDATION_XSD XSD})
	 * @param namespaceAware {@code true} if support for XML namespaces is to be provided
	 * @return the loaded {@link Document document}
	 * @throws Exception if an error occurs
	 */
	Document loadDocument(
			InputSource inputSource, EntityResolver entityResolver,
			ErrorHandler errorHandler, int validationMode, boolean namespaceAware)
			throws Exception;

}1
</code></pre>
<h5 id="1-1-defaultdocumentloader">1、1 DefaultDocumentLoader</h5>
<ul>
<li>#loadDocument由DefaultDocumentLoader实现</li>
</ul>
<pre><code>//&lt;1&gt; 创建 DocumentBuilderFactory
		DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);
		}
		// &lt;2&gt; 创建 DocumentBuilder
		DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
		// &lt;3&gt; 解析 XML InputSource 返回 Document 对象
		return builder.parse(inputSource);
</code></pre>
<ul>
<li>首先调用#createDocumentBuilderFactory来创建DocumentBuilderFactory对象</li>
</ul>
<pre><code>protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware)
			throws ParserConfigurationException {
		// 创建 DocumentBuilderFactor
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		//设置命名空间支持
		factory.setNamespaceAware(namespaceAware);
		//判断是否校验禁用
		if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) {
			//开启校验
			factory.setValidating(true);
			//判断是不是XSD模式
			if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {
				// Enforce namespace aware for XSD...
				//XSD模式下。强制将名称空间感知为XSD
				factory.setNamespaceAware(true);
				try {
					factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);
				}
				catch (IllegalArgumentException ex) {
					ParserConfigurationException pcex = new ParserConfigurationException(
							&quot;Unable to validate using XSD: Your JAXP provider [&quot; + factory +
							&quot;] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? &quot; +
							&quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;);
					pcex.initCause(ex);
					throw pcex;
				}
			}
		}

		return factory;
	}
</code></pre>
<ul>
<li>然后调用#createDocumentBuilder方法来创建DocumentBuilder对象</li>
</ul>
<pre><code>    	protected DocumentBuilder createDocumentBuilder(DocumentBuilderFactory factory,
			@Nullable EntityResolver entityResolver, @Nullable ErrorHandler errorHandler)
			throws ParserConfigurationException {
		//创建DocumentBuilder对象
		DocumentBuilder docBuilder = factory.newDocumentBuilder();
		if (entityResolver != null) {
			//设置entityResolver属性
			docBuilder.setEntityResolver(entityResolver);
		}
		if (errorHandler != null) {
			//设置errorHandler属性
			docBuilder.setErrorHandler(errorHandler);
		}
		return docBuilder;
	}
</code></pre>
<ul>
<li>最后调用DocumentBuilder#parse 返回Document对象</li>
</ul>
<h4 id="2-entityresolver">2、EntityResolver</h4>
<ul>
<li>XmlBeanDefinitionReader#getEntityResolver方法获取的EntityResolver，返回指定的解析器，如果没有指定，则构造一个未指定的默认解析器</li>
</ul>
<pre><code>	protected EntityResolver getEntityResolver() {
		if (this.entityResolver == null) {
			// Determine default EntityResolver to use.
			ResourceLoader resourceLoader = getResourceLoader();
			if (resourceLoader != null) {
				this.entityResolver = new ResourceEntityResolver(resourceLoader);
			}
			else {
				this.entityResolver = new DelegatingEntityResolver(getBeanClassLoader());
			}
		}
		return this.entityResolver;
	}

</code></pre>
<pre><code>- resourceLoader不为null，根据ResourLoader创建一个ResourceEntityResolver
- resourceLoader为null，创建一个DelegatingEntityResolver对象，默认委托给BeansDtdResolver和PluggableSchemaResolver
</code></pre>
<h5 id="2-1-entityresolver的子类">2、1  EntityResolver的子类</h5>
<ul>
<li>BeansDtdResolver ，EntityResolver接口的实现，Spring beans DTD的解析器，用来从classpath或jar文件中加载dtd。</li>
</ul>
<pre><code>    private static final String DTD_EXTENSION = &quot;.dtd&quot;;

    private static final String DTD_NAME = &quot;spring-beans&quot;;

</code></pre>
<ul>
<li>PluggableSchemaResolver, Entity接口的实现，读取classpath下所有匹配&quot;META-INF/spring.schemas&quot;成一个schema URL 和chema path对应的map</li>
</ul>
<pre><code>    /**
        * The location of the file that defines schema mappings.
        * Can be present in multiple JAR files.
	*/
	public static final String DEFAULT_SCHEMA_MAPPINGS_LOCATION = &quot;META-INF/spring.schemas&quot;;


	private static final Log logger = LogFactory.getLog(PluggableSchemaResolver.class);

	@Nullable
	private final ClassLoader classLoader;

	//schema文件地址
	private final String schemaMappingsLocation;

	/** Stores the mapping of schema URL -&gt; local schema path. */
	@Nullable
	private volatile Map&lt;String, String&gt; schemaMappings;
</code></pre>
<ul>
<li>DelegatingEntityResolver，实现EntityResolver接口，分别代理dtd的BeansDtdResolver和xml schemas的PluggableSchemaResolver</li>
</ul>
<pre><code>	/** Suffix for DTD files. */
	public static final String DTD_SUFFIX = &quot;.dtd&quot;;

	/** Suffix for schema definition files. */
	public static final String XSD_SUFFIX = &quot;.xsd&quot;;


	private final EntityResolver dtdResolver;

	private final EntityResolver schemaResolver;

    //默认
    public DelegatingEntityResolver(@Nullable ClassLoader classLoader) {
		this.dtdResolver = new BeansDtdResolver();
		this.schemaResolver = new PluggableSchemaResolver(classLoader);
	}

    //自定义
    public DelegatingEntityResolver(EntityResolver dtdResolver, EntityResolver schemaResolver) {
		Assert.notNull(dtdResolver, &quot;'dtdResolver' is required&quot;);
		Assert.notNull(schemaResolver, &quot;'schemaResolver' is required&quot;);
		this.dtdResolver = dtdResolver;
		this.schemaResolver = schemaResolver;
	}
</code></pre>
<ul>
<li>ResourceEntityResolver，继承DelegatingEntityResolver，通过resourceLoader来解析实体的引用</li>
</ul>
<pre><code>private final ResourceLoader resourceLoader;

public ResourceEntityResolver(ResourceLoader resourceLoader) {
	super(resourceLoader.getClassLoader());
	this.resourceLoader = resourceLoader;
}
</code></pre>
<h5 id="2-2-作用">2、2 作用</h5>
<ul>
<li>EntityResolver 的作用就是，通过实现它，应用可以自定义如何寻找【验证文件】的逻辑。</li>
<li>在loadDocument方法中涉及一个参数EntityResolver，何为EntityResolver？官网这样解释：如果SAX应用程序需要实现自定义处理外部文件实体，则必须实现此接口并使用setEntityResolver方法向SAX驱动器注册一个实例。也就是说，对于解析一个XML，SAX首先读取该XML文档上的说明，根据声明去寻找对应的DTD定义，一遍对一个文档进行一个验证。默认的寻找规则，则通过网络（实现上就是声明的DTD的URI地址）来下载对应的DTD声明。并进行认证。下载的过程是一个漫长的过程，而且网络中断或者不可用时，这里会报错，就是因为相应的DTD声明没有被找到的原因。EntityResolver的作用是项目本身就可以提供一个如何寻找DTD声明的方法，即由程序寻找DTD声明的过程，在实现时直接将此文档读取并返回给SAX即可。这样就避免了通过网络来寻找相应的声明</li>
</ul>
<pre><code>public interface EntityResolver {


    /**
     * Allow the application to resolve external entities.
     *
     * &lt;p&gt;The parser will call this method before opening any external
     * entity except the top-level document entity.  Such entities include
     * the external DTD subset and external parameter entities referenced
     * within the DTD (in either case, only if the parser reads external
     * parameter entities), and external general entities referenced
     * within the document element (if the parser reads external general
     * entities).  The application may request that the parser locate
     * the entity itself, that it use an alternative URI, or that it
     * use data provided by the application (as a character or byte
     * input stream).&lt;/p&gt;
     *
     * &lt;p&gt;Application writers can use this method to redirect external
     * system identifiers to secure and/or local URIs, to look up
     * public identifiers in a catalogue, or to read an entity from a
     * database or other input source (including, for example, a dialog
     * box).  Neither XML nor SAX specifies a preferred policy for using
     * public or system IDs to resolve resources.  However, SAX specifies
     * how to interpret any InputSource returned by this method, and that
     * if none is returned, then the system ID will be dereferenced as
     * a URL.  &lt;/p&gt;
     *
     * &lt;p&gt;If the system identifier is a URL, the SAX parser must
     * resolve it fully before reporting it to the application.&lt;/p&gt;
     *
     * @param publicId The public identifier of the external entity
     *        being referenced, or null if none was supplied.
     * @param systemId The system identifier of the external entity
     *        being referenced.
     * @return An InputSource object describing the new input source,
     *         or null to request that the parser open a regular
     *         URI connection to the system identifier.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @exception java.io.IOException A Java-specific IO exception,
     *            possibly the result of creating a new InputStream
     *            or Reader for the InputSource.
     * @see org.xml.sax.InputSource
     */
    public abstract InputSource resolveEntity (String publicId,
                                               String systemId)
        throws SAXException, IOException;

}
</code></pre>
<ul>
<li>
<p>接口方法接受两个参数publicId和systemId，并且返回InputSource对象。两个参数声明如下：</p>
<ul>
<li>publicId：被引用的外部实体的公共标识符，如果没有提供，则返回null</li>
<li>systemId：被引用的外部实体的系统不是福</li>
</ul>
</li>
<li>
<p>这两个参数的实际内容和具体的验证模式的关系如下</p>
<ul>
<li>
<p>XSD验证模式</p>
<ul>
<li>publicId：null</li>
<li>systemId：http://www.springframework.org/schema/beans/spring-beans.xsd</li>
</ul>
</li>
<li>
<p>DTD验证模式</p>
<ul>
<li>publicId：-//SPRING//DTD BEAN 2.0//EN</li>
<li>systemId：http://www.springframework.org/dtd/spring-beans.dtd</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-3-delegatingentityresolver">2、3 DelegatingEntityResolver</h5>
<ul>
<li>Spring中使用DelegatingEntityResolver为EntityResolver的实现类
<ul>
<li>如果是DTD验证模式，使用BeansDtdResolver来进行解析</li>
<li>如果是XSD验证模式，使用PluggableSchemaResolver来进行解析</li>
</ul>
</li>
</ul>
<pre><code>	@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId)
			throws SAXException, IOException {
		//DTD验证模式
		if (systemId != null) {
			if (systemId.endsWith(DTD_SUFFIX)) {
				return this.dtdResolver.resolveEntity(publicId, systemId);
			}
			//XSD验证模式
			else if (systemId.endsWith(XSD_SUFFIX)) {
				return this.schemaResolver.resolveEntity(publicId, systemId);
			}
		}

		// Fall back to the parser's default behavior.
		return null;
	}
</code></pre>
<h5 id="2-4-beansdtdresolver">2、 4 BeansDtdResolver</h5>
<pre><code>
	@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws IOException {
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Trying to resolve XML entity with public ID [&quot; + publicId +
					&quot;] and system ID [&quot; + systemId + &quot;]&quot;);
		}
		//必须是DTD结尾
		if (systemId != null &amp;&amp; systemId.endsWith(DTD_EXTENSION)) {
			//获取最后一个“/”的位置
			int lastPathSeparator = systemId.lastIndexOf('/');
			//获取spring-beans的位置
			int dtdNameStart = systemId.indexOf(DTD_NAME, lastPathSeparator);
			if (dtdNameStart != -1) {//找到
				String dtdFile = DTD_NAME + DTD_EXTENSION;
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Trying to locate [&quot; + dtdFile + &quot;] in Spring jar on classpath&quot;);
				}
				try {
					//创建ClassPathResource
					Resource resource = new ClassPathResource(dtdFile, getClass());
					//创建InputSource对象，兵器设置publicId， systemId
					InputSource source = new InputSource(resource.getInputStream());
					source.setPublicId(publicId);
					source.setSystemId(systemId);
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Found beans DTD [&quot; + systemId + &quot;] in classpath: &quot; + dtdFile);
					}
					return source;
				}
				catch (FileNotFoundException ex) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Could not resolve beans DTD [&quot; + systemId + &quot;]: not found in classpath&quot;, ex);
					}
				}
			}
		}
		//使用默认的行为，从网络上下载
		// Fall back to the parser's default behavior.
		return null;
	}
</code></pre>
<ul>
<li>BeansDtdResolver解析DTD的过程，只是对systemId进行了简单的校验，然后构造InputSource对象，设置publicId和systemId</li>
</ul>
<h5 id="2-5-pluggableschemaresolver">2、 5 PluggableSchemaResolver</h5>
<pre><code>@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws IOException {
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Trying to resolve XML entity with public id [&quot; + publicId +
					&quot;] and system id [&quot; + systemId + &quot;]&quot;);
		}

		if (systemId != null) {
			//获取Resource 所在的位置
			String resourceLocation = getSchemaMappings().get(systemId);
			if (resourceLocation == null &amp;&amp; systemId.startsWith(&quot;https:&quot;)) {
				// Retrieve canonical http schema mapping even for https declaration
				resourceLocation = getSchemaMappings().get(&quot;http:&quot; + systemId.substring(6));
			}
			if (resourceLocation != null) {
				//创建ClassPathResource对象
				Resource resource = new ClassPathResource(resourceLocation, this.classLoader);
				try {
					//创建InputSource对象。设置publicId和systemId
					InputSource source = new InputSource(resource.getInputStream());
					source.setPublicId(publicId);
					source.setSystemId(systemId);
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Found XML schema [&quot; + systemId + &quot;] in classpath: &quot; + resourceLocation);
					}
					return source;
				}
				catch (FileNotFoundException ex) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Could not find XML schema [&quot; + systemId + &quot;]: &quot; + resource, ex);
					}
				}
			}
		}

		// Fall back to the parser's default behavior.
		return null;
	}
</code></pre>
<ul>
<li>首先调用getSchemaMappings().get(systemId)，获取映射表来获取资源的位置</li>
</ul>
<pre><code>	/**
	 * Load the specified schema mappings lazily.
	 */
	private Map&lt;String, String&gt; getSchemaMappings() {
		Map&lt;String, String&gt; schemaMappings = this.schemaMappings;
		//双重检查锁，实现schemaMappings的单例
		if (schemaMappings == null) {
			synchronized (this) {
				schemaMappings = this.schemaMappings;
				if (schemaMappings == null) {
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Loading schema mappings from [&quot; + this.schemaMappingsLocation + &quot;]&quot;);
					}
					try {
						// 以 Properties 的方式，读取 schemaMappingsLocation
						Properties mappings =
								PropertiesLoaderUtils.loadAllProperties(this.schemaMappingsLocation, this.classLoader);
						if (logger.isTraceEnabled()) {
							logger.trace(&quot;Loaded schema mappings: &quot; + mappings);
						}
						//将mappings初始化到schemaMappings
						schemaMappings = new ConcurrentHashMap&lt;&gt;(mappings.size());
						CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings);
						this.schemaMappings = schemaMappings;
					}
					catch (IOException ex) {
						throw new IllegalStateException(
								&quot;Unable to load schema mappings from location [&quot; + this.schemaMappingsLocation + &quot;]&quot;, ex);
					}
				}
			}
		}
		return schemaMappings;
	}
</code></pre>
<ul>
<li>部分映射表<br>
<img src="https://guyang233.github.io/post-images/1584172944557.png" alt="" loading="lazy"></li>
<li>然后根据传入的systemId来获取映射表对应文件的位置</li>
<li>最后根据resourceLocation来构造InputSource对象，设置publicId和systemId</li>
</ul>
<h5 id="2-6-resourceentityresolver">2、 6 ResourceEntityResolver</h5>
<pre><code>@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId)
			throws SAXException, IOException {
		//调用父类的方法
		InputSource source = super.resolveEntity(publicId, systemId);
		//解析失败，使用resourceLoader来解析。通过对systemId的解码操作来获取文件资源的位置，通过resourceLoader来获取Resource对应，设置publicId和systemId
		if (source == null &amp;&amp; systemId != null) {
			String resourcePath = null;
			try {
				String decodedSystemId = URLDecoder.decode(systemId, &quot;UTF-8&quot;);
				String givenUrl = new URL(decodedSystemId).toString();
				String systemRootUrl = new File(&quot;&quot;).toURI().toURL().toString();
				// Try relative to resource base if currently in system root.
				if (givenUrl.startsWith(systemRootUrl)) {
					resourcePath = givenUrl.substring(systemRootUrl.length());
				}
			}
			catch (Exception ex) {
				// Typically a MalformedURLException or AccessControlException.
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Could not resolve XML entity [&quot; + systemId + &quot;] against system root URL&quot;, ex);
				}
				// No URL (or no resolvable URL) -&gt; try relative to resource base.
				resourcePath = systemId;
			}
			if (resourcePath != null) {
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Trying to locate XML entity [&quot; + systemId + &quot;] as resource [&quot; + resourcePath + &quot;]&quot;);
				}
				Resource resource = this.resourceLoader.getResource(resourcePath);
				source = new InputSource(resource.getInputStream());
				source.setPublicId(publicId);
				source.setSystemId(systemId);
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Found XML entity [&quot; + systemId + &quot;]: &quot; + resource);
				}
			}
			else if (systemId.endsWith(DTD_SUFFIX) || systemId.endsWith(XSD_SUFFIX)) {
				// External dtd/xsd lookup via https even for canonical http declaration
				String url = systemId;
				if (url.startsWith(&quot;http:&quot;)) {
					url = &quot;https:&quot; + url.substring(5);
				}
				try {
					source = new InputSource(new URL(url).openStream());
					source.setPublicId(publicId);
					source.setSystemId(systemId);
				}
				catch (IOException ex) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Could not resolve XML entity [&quot; + systemId + &quot;] through URL [&quot; + url + &quot;]&quot;, ex);
					}
					// Fall back to the parser's default behavior.
					source = null;
				}
			}
		}

		return source;
	}
</code></pre>
<ul>
<li>首先调用父类的方法来解析</li>
<li>如果父类解析失败，则使用ResourceLoader来对systemId对应的Resouce进行读取</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC之获取验证模型]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-huo-qu-yan-zheng-mo-xing</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-huo-qu-yan-zheng-mo-xing">
        </link>
        <updated>2020-03-09T13:35:09.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>IoC加载定义核心方法是#doLoadDocument方法中主要做三件事
<ul>
<li>1、调用#getValidationModeForResource方法，获取指定资源（xml）的验证模式</li>
<li>2、调用DocumentLoader#loadDocument方法，获取XML Document实例</li>
<li>3、调用#registerBeanDefinitions方法，根据获取的文档实例，注册Bean信息</li>
<li>4、主要是分析第一步，获取XML文件的验证模式。为什么要获取验证模式呢？原因主要是：XML文件的验证模式保证了XML文件的正确性</li>
</ul>
</li>
</ul>
<h4 id="1-dtd与xsd的区别">1、 DTD与XSD的区别</h4>
<ul>
<li>1、DTD
<ul>
<li>DTD（文档类型定义），即文档类型定义，为XML文件的验证机制，属于XML文件中组成的部分。DTD是一种保证XML文档格式正确的有效验证方式，它定义了相关XML文档的元素，实际上DTD就相当于XML中的“词汇”和“语法”，我们可以通过比较XML文件和DTD文件来看文档是否符合规范，元素和标签。使用是否正确</li>
<li>要在Spring中使用DTD，需要在Spring XML文件标题中声明</li>
</ul>
</li>
</ul>
<pre><code>&lt;？xml version =“ 1.0” encoding =“ UTF-8”？&gt; 
&lt;！DOCTYPE bean PUBLIC“-// SPRING // DTD BEAN // EN”“ http://www.springframework.org/dtd/spring- beans.dtd“&gt;
</code></pre>
<pre><code>-  DTD在一定阶段推动了XML得发展，本身存在着一些缺陷
    - 1、没有使用XML格式，而是自己定义的一套格式，相对解析器的重用性较差；而且DTD的内置和访问没有标准的编程接口，因此解析器很难简单的解析DTD文档
    - 2、DTD对元素的类型限制上限；同时其他的约束力也较弱
    - 3、DTD扩展能力较差
    - 4、基于正则表达式的DTD文档的描述能力有限
</code></pre>
<ul>
<li>2、XSD
<ul>
<li>针对DTD的缺陷，W3C在2001年推出XSD。XSD（XML模式定义）即XML模式语言。XML模式本身就是一个XML文档，使用的就是XML语法，因此可以很方便的解析XSD文档。相对于DTD，XSD具有如下优势
<ul>
<li>1、XML模式基于XML，没有专门的语法</li>
<li>2、XML架构可以像其他XML文件一样的解析和处理</li>
<li>3、XML Schema比DTD提供了丰富的数据模型</li>
<li>4、XML模式提供可扩展的数据模型</li>
<li>5、XML Schema支持综合命名空间</li>
<li>6、XML模式支持属性组</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-getvalidationmodeforresource">2、 getValidationModeForResource</h4>
<pre><code>	/**
	 * Indicates that the validation should be disabled.
	 */
	//禁用验证模式
	public static final int VALIDATION_NONE = XmlValidationModeDetector.VALIDATION_NONE;

	/**
	 * Indicates that the validation mode should be detected automatically.
	 */
	//自动校验模式
	public static final int VALIDATION_AUTO = XmlValidationModeDetector.VALIDATION_AUTO;

	/**
	 * Indicates that DTD validation should be used.
	 */
	//DTD校验模式
	public static final int VALIDATION_DTD = XmlValidationModeDetector.VALIDATION_DTD;

	/**
	 * Indicates that XSD validation should be used.
	 */
	//XSD验证模式
	public static final int VALIDATION_XSD = XmlValidationModeDetector.VALIDATION_XSD;

	/**
	 * 验证模式。默认为自动模式
	 */
	private int validationMode = VALIDATION_AUTO;

    protected int getValidationModeForResource(Resource resource) {
		//&lt;1&gt;、获取指定的验证模式
		int validationModeToUse = getValidationMode();
		//首先，如果手动指定，则直接返回
		if (validationModeToUse != VALIDATION_AUTO) {
			return validationModeToUse;
		}
		//&lt;2&gt;、 其次，自动获取验证模式
		int detectedMode = detectValidationMode(resource);
		if (detectedMode != VALIDATION_AUTO) {
			return detectedMode;
		}
		// 最后，使用 VALIDATION_XSD 做为默认
		// Hmm, we didn't get a clear indication... Let's assume XSD,
		// since apparently no DTD declaration has been found up until
		// detection stopped (before finding the document's root tag).
		return VALIDATION_XSD;
	}
</code></pre>
<ul>
<li>在&lt;1&gt;处，调用#getValidationMode方法，获取指定的验证模式。如果没有手动指定，则直接返回。另外，对于属性的设置和获得的代码。代码如下：</li>
</ul>
<pre><code>public void setValidationMode(int validationMode) {
	this.validationMode = validationMode;
}

public int getValidationMode() {
	return this.validationMode;
}
</code></pre>
<ul>
<li>&lt;2&gt;处，调用#detectValidationMode方法，自动获取验证模式</li>
</ul>
<pre><code>//XML 验证模式探测器
private final XmlValidationModeDetector validationModeDetector = new XmlValidationModeDetector();

protected int detectValidationMode(Resource resource) {
		//不可读，抛出异常
		if (resource.isOpen()) {
			throw new BeanDefinitionStoreException(
					&quot;Passed-in Resource [&quot; + resource + &quot;] contains an open stream: &quot; +
					&quot;cannot determine validation mode automatically. Either pass in a Resource &quot; +
					&quot;that is able to create fresh streams, or explicitly specify the validationMode &quot; +
					&quot;on your XmlBeanDefinitionReader instance.&quot;);
		}
		//打开InputStream流
		InputStream inputStream;
		try {
			inputStream = resource.getInputStream();
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(
					&quot;Unable to determine validation mode for [&quot; + resource + &quot;]: cannot open InputStream. &quot; +
					&quot;Did you attempt to load directly from a SAX InputSource without specifying the &quot; +
					&quot;validationMode on your XmlBeanDefinitionReader instance?&quot;, ex);
		}

		try {
			//&lt;X&gt;获取相应的验证模式
			return this.validationModeDetector.detectValidationMode(inputStream);
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(&quot;Unable to determine validation mode for [&quot; +
					resource + &quot;]: an error occurred whilst reading from the InputStream.&quot;, ex);
		}
	}
</code></pre>
<pre><code>- 核心在于&lt;X&gt;处，调用XmlValidationModeDetector#detectValidationMode方法，获取相应的验证模式。
</code></pre>
<ul>
<li>最后使用VALIDATION_XSD 作为默认</li>
</ul>
<h4 id="3-xmlvalidationmodedetector">3、XmlValidationModeDetector</h4>
<ul>
<li>XmlValidationModeDetector，XML验证器模式探测器</li>
</ul>
<pre><code>public int detectValidationMode(InputStream inputStream) throws IOException {
		// Peek into the file to look for DOCTYPE.
		BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
		try {
			//是否为DTD校验模式，默认为非DTD模式，即XSD模式
			boolean isDtdValidated = false;
			String content;
			// &lt;0&gt; 循环，逐行读取 XML 文件的内容
			while ((content = reader.readLine()) != null) {
				content = consumeCommentTokens(content);
				// 跳过，如果是注释，或者
				if (this.inComment || !StringUtils.hasText(content)) {
					continue;
				}
				// &lt;1&gt; 包含 DOCTYPE 为 DTD 模式
				if (hasDoctype(content)) {
					isDtdValidated = true;
					break;
				}
				// &lt;2&gt;  hasOpeningTag 方法会校验，如果这一行有 &lt; ，并且 &lt; 后面跟着的是字母，则返回 true 。
				if (hasOpeningTag(content)) {
					// End of meaningful data...
					break;
				}
			}
			// 返回 VALIDATION_DTD or VALIDATION_XSD 模式
			return (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);
		}
		catch (CharConversionException ex) {
			// &lt;3&gt; 返回 VALIDATION_AUTO 模式
			// Choked on some character encoding...
			// Leave the decision up to the caller.
			return VALIDATION_AUTO;
		}
		finally {
			reader.close();
		}
	}
</code></pre>
<ul>
<li>&lt;0&gt;处，从代码看，主要是通过读取XML文件的内容，来自动判断</li>
<li>&lt;1&gt;处，调用#hasDoctype方法，判断内容中如果包含有“DOCTYPE”，则为DTD验证模式。</li>
</ul>
<pre><code>	private static final String DOCTYPE = &quot;DOCTYPE&quot;;

	/**
	 * Does the content contain the DTD DOCTYPE declaration?
	 */
	private boolean hasDoctype(String content) {
		return content.contains(DOCTYPE);
	}
</code></pre>
<ul>
<li>&lt;2&gt;处，调用#hasOpeningTag方法，判断如果这一行包含&lt;,并且&lt;紧跟着的是字母，则为XSD验证模式</li>
</ul>
<pre><code>	private boolean hasOpeningTag(String content) {
		if (this.inComment) {
			return false;
		}
		int openTagIndex = content.indexOf('&lt;');// &lt;存在
		return (openTagIndex &gt; -1 &amp;&amp; (content.length() &gt; openTagIndex + 1) &amp;&amp; // &lt; 后面还有内容
				Character.isLetter(content.charAt(openTagIndex + 1))); // &lt; 后面的内容是字母
	}
</code></pre>
<ul>
<li>&lt;3&gt;处，如果发生CharConversionException异常，则为VALIDATION_AUTO模式</li>
</ul>
]]></content>
    </entry>
</feed>