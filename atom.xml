<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://guyang233.github.io</id>
    <title>Gridea</title>
    <updated>2020-03-22T07:02:53.846Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://guyang233.github.io"/>
    <link rel="self" href="https://guyang233.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://guyang233.github.io/images/avatar.png</logo>
    <icon>https://guyang233.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[IoC 之解析 <bean> 标签：开启解析进程]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-jie-xi-lessbeangreater-biao-qian-kai-qi-jie-xi-jin-cheng</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-jie-xi-lessbeangreater-biao-qian-kai-qi-jie-xi-jin-cheng">
        </link>
        <updated>2020-03-22T06:46:48.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-processbeandefinition">1、processBeanDefinition</h3>
<ul>
<li>解析bean标签</li>
</ul>
<pre><code>/**
	 * Process the given bean element, parsing the bean definition
	 * and registering it with the registry.
	 */
	protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) {
		//进行Bean标签解析
		//如果解析成功，返回BeanDefinitionHolder对象，而BeanDefinitionHolder为name和alias的BeanDefinition 对象
		//若果解析失败，返回null
		BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);
		if (bdHolder != null) {
			//进行自定义标签的解析
			bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);
			try {
				//进行BeanDefinition注册
				// Register the final decorated instance.
				BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(&quot;Failed to register bean definition with name '&quot; +
						bdHolder.getBeanName() + &quot;'&quot;, ele, ex);
			}
			//发出响应事件，通知相关的通知器，已完成对该Bean标签的解析
			// Send registration event.
			getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder));
		}
	}
</code></pre>
<ul>
<li>步骤解析
<ul>
<li>调用#parseBeanDefinitionElement方法来对标签进行解析
<ul>
<li>解析成功，返回BeanDefinitionHolder对象</li>
<li>解析失败，返回null</li>
</ul>
</li>
<li>如果BeanDefinitionHolder实例不为null， 调用#decorateBeanDefinitionIfRequired方法对自定义标签进行解析</li>
<li>解析完成之后，调用BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());来进行Bean注册</li>
<li>最后发出相应事件，通知相关的监听器，完成Bean标签的解析</li>
</ul>
</li>
</ul>
<h3 id="2-parsebeandefinitionelement">2、parseBeanDefinitionElement</h3>
<pre><code>	/**
	 * Parses the supplied {@code &lt;bean&gt;} element. May return {@code null}
	 * if there were errors during parse. Errors are reported to the
	 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
	 */
	@Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) {
		return parseBeanDefinitionElement(ele, null);
	}


    	/**
	 * Parses the supplied {@code &lt;bean&gt;} element. May return {@code null}
	 * if there were errors during parse. Errors are reported to the
	 * {@link org.springframework.beans.factory.parsing.ProblemReporter}.
	 */
	@Nullable
	public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, @Nullable BeanDefinition containingBean) {
		//解析id和name
		String id = ele.getAttribute(ID_ATTRIBUTE);
		String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);
		//计算别名集合
		List&lt;String&gt; aliases = new ArrayList&lt;&gt;();
		if (StringUtils.hasLength(nameAttr)) {
			String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);
			aliases.addAll(Arrays.asList(nameArr));
		}
		//优先使用BeanName
		String beanName = id;
		//其次使用别名集合中的第一个
		if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) {
			//移除别名集合
			beanName = aliases.remove(0);
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;No XML 'id' specified - using '&quot; + beanName +
						&quot;' as bean name and &quot; + aliases + &quot; as aliases&quot;);
			}
		}
		//检查BeanName的唯一性
		if (containingBean == null) {
			checkNameUniqueness(beanName, aliases, ele);
		}
		//解析属性，构造AbstractBeanDefinition对象
		AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);
		if (beanDefinition != null) {
			//beanName为空。使用BeanName生成规则
			if (!StringUtils.hasText(beanName)) {
				try {
					if (containingBean != null) {
						//生成唯一的BeanName
						beanName = BeanDefinitionReaderUtils.generateBeanName(
								beanDefinition, this.readerContext.getRegistry(), true);
					}
					else {
						//生成唯一的BeanName
						beanName = this.readerContext.generateBeanName(beanDefinition);
						// Register an alias for the plain bean class name, if still possible,
						// if the generator returned the class name plus a suffix.
						// This is expected for Spring 1.2/2.0 backwards compatibility.
						String beanClassName = beanDefinition.getBeanClassName();
						if (beanClassName != null &amp;&amp;
								beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;
								!this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) {
							aliases.add(beanClassName);
						}
					}
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Neither XML 'id' nor 'name' specified - &quot; +
								&quot;using generated bean name [&quot; + beanName + &quot;]&quot;);
					}
				}
				catch (Exception ex) {
					error(ex.getMessage(), ele);
					return null;
				}
			}
			//创建返回BeanDefinitionHolder对象
			String[] aliasesArray = StringUtils.toStringArray(aliases);
			return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);
		}

		return null;
	}
</code></pre>
<ul>
<li>这个方法还没有对Bean标签进行解析，只是在解析动作之前做了一些功能架构，主要的工作有
<ul>
<li>解析id、name属性，确定alias结合</li>
<li>检测BeanName是否唯一</li>
</ul>
</li>
<li>BeanName的命名规则
<ul>
<li>id不为空， BeanName就是id</li>
<li>id为空，BeanName就是别名集合中第一个元素</li>
<li>如果两者都为空，那么根据规则来设置生成BeanName。</li>
</ul>
</li>
<li>#parseBeanDefinitionElement，对属性进行解析</li>
<li>根据所获取的信息（beanName， alias，BeanDefinition构造BeanDefinitionHolder对象</li>
<li>检查BeanName唯一性的代码</li>
</ul>
<pre><code>/**
	 * Validate that the specified bean name and aliases have not been used already
	 * within the current level of beans element nesting.
	 */
	protected void checkNameUniqueness(String beanName, List&lt;String&gt; aliases, Element beanElement) {
		//寻找是否已经使用过BeanName
		String foundName = null;
		//先去已经使用过名字的集合中查找
		if (StringUtils.hasText(beanName) &amp;&amp; this.usedNames.contains(beanName)) {
			foundName = beanName;
		}
		//已经使用过名字的集合中查找匹配的别名
		if (foundName == null) {
			foundName = CollectionUtils.findFirstMatch(this.usedNames, aliases);
		}
		if (foundName != null) {
			error(&quot;Bean name '&quot; + foundName + &quot;' is already used in this &lt;beans&gt; element&quot;, beanElement);
		}
		//没有的话。把BeanName和别名集合添加进去
		this.usedNames.add(beanName);
		this.usedNames.addAll(aliases);
	}
</code></pre>
<ul>
<li>BeanDefinitionHolder的简化代码</li>
</ul>
<pre><code>/**
 * BeanDefinition 对象
 */
private final BeanDefinition beanDefinition;
/**
 * Bean 名字
 */
private final String beanName;
/**
 * 别名集合
 */
@Nullable
private final String[] aliases;
</code></pre>
<h4 id="2-1-parsebeandefinitionelement">2、1 parseBeanDefinitionElement</h4>
<ul>
<li>对属性进行解析并且封装为AbstractBeanDefinition</li>
</ul>
<pre><code>/**
	 * Parse the bean definition itself, without regard to name or aliases. May return
	 * {@code null} if problems occurred during the parsing of the bean definition.
	 */
		@Nullable
	public AbstractBeanDefinition parseBeanDefinitionElement(
			Element ele, String beanName, @Nullable BeanDefinition containingBean) {

		this.parseState.push(new BeanEntry(beanName));
		//解析class属性
		String className = null;
		if (ele.hasAttribute(CLASS_ATTRIBUTE)) {
			className = ele.getAttribute(CLASS_ATTRIBUTE).trim();
		}
		//解析parent属性
		String parent = null;
		if (ele.hasAttribute(PARENT_ATTRIBUTE)) {
			parent = ele.getAttribute(PARENT_ATTRIBUTE);
		}

		try {
			//创建用于承载属性的AbstractBeanDefinition
			AbstractBeanDefinition bd = createBeanDefinition(className, parent);
			//默认解析Bean的各种属性
			parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);
			//提取description
			bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));
			// tips：
			// 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，
			// 解析出来以后的信息都放到 bd 的属性中
			// 解析元数据 &lt;meta /&gt;
			parseMetaElements(ele, bd);
			// 解析 lookup-method 属性 &lt;lookup-method /&gt;
			parseLookupOverrideSubElements(ele, bd.getMethodOverrides());
			// 解析 replaced-method 属性 &lt;replaced-method /&gt;
			parseReplacedMethodSubElements(ele, bd.getMethodOverrides());

			// 解析构造函数参数 &lt;constructor-arg /&gt;
			parseConstructorArgElements(ele, bd);
			// 解析 property 子元素 &lt;property /&gt;
			parsePropertyElements(ele, bd);
			// 解析 qualifier 子元素 &lt;qualifier /&gt;
			parseQualifierElements(ele, bd);

			bd.setResource(this.readerContext.getResource());
			bd.setSource(extractSource(ele));

			return bd;
		}
		catch (ClassNotFoundException ex) {
			error(&quot;Bean class [&quot; + className + &quot;] not found&quot;, ele, ex);
		}
		catch (NoClassDefFoundError err) {
			error(&quot;Class that bean class [&quot; + className + &quot;] depends on not found&quot;, ele, err);
		}
		catch (Throwable ex) {
			error(&quot;Unexpected failure during bean definition parsing&quot;, ele, ex);
		}
		finally {
			this.parseState.pop();
		}

		return null;
	}
</code></pre>
<h4 id="2-2-createbeandefinition">2、2 createBeanDefinition</h4>
<ul>
<li>创建AbstractBeanDefinition</li>
</ul>
<pre><code>/**
	 * Create a bean definition for the given class name and parent name.
	 * @param className the name of the bean class
	 * @param parentName the name of the bean's parent bean
	 * @return the newly created bean definition
	 * @throws ClassNotFoundException if bean class resolution was attempted but failed
	 */
	protected AbstractBeanDefinition createBeanDefinition(@Nullable String className, @Nullable String parentName)
			throws ClassNotFoundException {

		return BeanDefinitionReaderUtils.createBeanDefinition(
				parentName, className, this.readerContext.getBeanClassLoader());
	}

    /**
	 * Create a new GenericBeanDefinition for the given parent name and class name,
	 * eagerly loading the bean class if a ClassLoader has been specified.
	 * @param parentName the name of the parent bean, if any
	 * @param className the name of the bean class, if any
	 * @param classLoader the ClassLoader to use for loading bean classes
	 * (can be {@code null} to just register bean classes by name)
	 * @return the bean definition
	 * @throws ClassNotFoundException if the bean class could not be loaded
	 */
	public static AbstractBeanDefinition createBeanDefinition(
			@Nullable String parentName, @Nullable String className, @Nullable ClassLoader classLoader) throws ClassNotFoundException {

		GenericBeanDefinition bd = new GenericBeanDefinition();
		bd.setParentName(parentName);
		if (className != null) {
			if (classLoader != null) {
				bd.setBeanClass(ClassUtils.forName(className, classLoader));
			}
			else {
				bd.setBeanClassName(className);
			}
		}
		return bd;
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC 之解析 Bean：解析 import 标签]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-jie-xi-beanjie-xi-import-biao-qian</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-jie-xi-beanjie-xi-import-biao-qian">
        </link>
        <updated>2020-03-16T14:33:30.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>根节点或者子节点采用默认的命名空间的话，采用#parseDefaultElement解析</li>
<li>如果没有采用默认空间命名的话，采用#parseCustomElement解析</li>
<li>默认解析的代码如下：</li>
</ul>
<pre><code>public static final String IMPORT_ELEMENT = &quot;import&quot;;

public static final String ALIAS_ELEMENT = &quot;alias&quot;;

public static final String BEAN_ELEMENT = BeanDefinitionParserDelegate.BEAN_ELEMENT;

public static final String BEAN_ELEMENT = &quot;bean&quot;;

public static final String NESTED_BEANS_ELEMENT = &quot;beans&quot;;

private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
		//解析默认标签import
		if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
			importBeanDefinitionResource(ele);
		}
		//解析默认标签alias
		else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
			processAliasRegistration(ele);
		}
		//解析默认标签bean
		else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
			processBeanDefinition(ele, delegate);
		}
		//解析默认标签beans
		else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
			// recurse
			doRegisterBeanDefinitions(ele);
		}
	}
</code></pre>
<h4 id="1-import示例">1、 import示例</h4>
<ul>
<li>避免过多的配置文件，Spring提供import配置文件的方式</li>
</ul>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;

    &lt;import resource=&quot;spring-student.xml&quot;/&gt;

    &lt;import resource=&quot;spring-student-dtd.xml&quot;/&gt;

&lt;/beans&gt;
</code></pre>
<ul>
<li>spring.xml配置文件中，使用import标签的方式导入其他模块的配置文件，简化了配置文件维护的复杂度，便于管理
<ul>
<li>如果有配置需要修改直接修改对应的配置文件即可</li>
<li>若有新的配置文件需要被引入的话，直接添加import引入即可</li>
</ul>
</li>
</ul>
<h4 id="2-importbeandefinitionresource">2、 importBeanDefinitionResource</h4>
<ul>
<li>Spring调用#importBeanDefinitionResource方法来对import标签进行解析</li>
</ul>
<pre><code>/**
	 * Parse an &quot;import&quot; element and load the bean definitions
	 * from the given resource into the bean factory.
	 */
	protected void importBeanDefinitionResource(Element ele) {
		//获取Resource 的值
		String location = ele.getAttribute(RESOURCE_ATTRIBUTE);
		//为空，直接退出
		if (!StringUtils.hasText(location)) {
			getReaderContext().error(&quot;Resource location must not be empty&quot;, ele);
			return;
		}
		//解析系统属性，格式如:&quot;${user.dir}&quot;
		// Resolve system properties: e.g. &quot;${user.dir}&quot;
		location = getReaderContext().getEnvironment().resolveRequiredPlaceholders(location);
		//实际Resource的集合，即import的地址，有哪些Resource资源
		Set&lt;Resource&gt; actualResources = new LinkedHashSet&lt;&gt;(4);

		//判断location是相对路径还是绝对路径
		// Discover whether the location is an absolute or relative URI
		boolean absoluteLocation = false;
		try {
			absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();
		}
		catch (URISyntaxException ex) {
			// cannot convert to an URI, considering the location relative
			// unless it is the well-known Spring prefix &quot;classpath*:&quot;
		}

		// Absolute or relative?
		//绝对路径
		if (absoluteLocation) {
			try {
				//添加配置文件地址的Resource到actualResources中，并且加载对应的BeanDefinition
				int importCount = getReaderContext().getReader().loadBeanDefinitions(location, actualResources);
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from URL location [&quot; + location + &quot;]&quot;);
				}
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(
						&quot;Failed to import bean definitions from URL location [&quot; + location + &quot;]&quot;, ele, ex);
			}
		}
		//相对路径
		else {
			// No URL -&gt; considering resource location as relative to the current file.
			try {
				int importCount;
				//创建相对路径的Resource
				Resource relativeResource = getReaderContext().getResource().createRelative(location);
				if (relativeResource.exists()) {
					//加载relativeResource对应的BeanDefinition
					importCount = getReaderContext().getReader().loadBeanDefinitions(relativeResource);
					//添加到actualResources中
					actualResources.add(relativeResource);
				}
				//不存在
				else {
					//获取根路径地址
					String baseLocation = getReaderContext().getResource().getURL().toString();
					//添加配置文件地址的 Resource 到 actualResources 中，并加载相应的 BeanDefinition 们
					importCount = getReaderContext().getReader().loadBeanDefinitions(
							StringUtils.applyRelativePath(baseLocation, location), actualResources);
				}
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Imported &quot; + importCount + &quot; bean definitions from relative location [&quot; + location + &quot;]&quot;);
				}
			}
			catch (IOException ex) {
				getReaderContext().error(&quot;Failed to resolve current resource location&quot;, ele, ex);
			}
			catch (BeanDefinitionStoreException ex) {
				getReaderContext().error(
						&quot;Failed to import bean definitions from relative location [&quot; + location + &quot;]&quot;, ele, ex);
			}
		}
		//解析成功后，进行监听器激活处理
		Resource[] actResArray = actualResources.toArray(new Resource[0]);
		getReaderContext().fireImportProcessed(location, actResArray, extractSource(ele));
	}
</code></pre>
<ul>
<li>解析import的流程
<ul>
<li>获取Resource的值，值表示对应的资源的路径
<ul>
<li>解析路径中的系统属性，例如“${user.dir}”</li>
</ul>
</li>
<li>判断是绝对路径还是相对路径
<ul>
<li>绝对路径，递归调用Bean的解析过程，进行另一次的解析</li>
<li>相对路径，计算出绝对路径得到Resource，然后进行解析</li>
</ul>
</li>
<li>通知监听器，解析完毕</li>
</ul>
</li>
</ul>
<h5 id="21-判断路径">2.1 判断路径</h5>
<pre><code>	absoluteLocation = ResourcePatternUtils.isUrl(location) || ResourceUtils.toURI(location).isAbsolute();
</code></pre>
<ul>
<li>判断绝对路径的规则如下：
<ul>
<li>以classpath*：或者classpath：开头的为绝对路径</li>
<li>能够通过该location构建出java.net.URL的为绝对路径</li>
<li>根据location构造java.net.URI判断调用#isAbsolute方法，判断是否是绝对路径</li>
</ul>
</li>
</ul>
<h5 id="22-处理绝对路径">2.2 处理绝对路径</h5>
<ul>
<li>如果location是绝对路径的话，调用#loadBeanDefinitions方法</li>
</ul>
<pre><code>/**
	 * Load bean definitions from the specified resource location.
	 * &lt;p&gt;The location can also be a location pattern, provided that the
	 * ResourceLoader of this bean definition reader is a ResourcePatternResolver.
	 * @param location the resource location, to be loaded with the ResourceLoader
	 * (or ResourcePatternResolver) of this bean definition reader
	 * @param actualResources a Set to be filled with the actual Resource objects
	 * that have been resolved during the loading process. May be {@code null}
	 * to indicate that the caller is not interested in those Resource objects.
	 * @return the number of bean definitions found
	 * @throws BeanDefinitionStoreException in case of loading or parsing errors
	 * @see #getResourceLoader()
	 * @see #loadBeanDefinitions(org.springframework.core.io.Resource)
	 * @see #loadBeanDefinitions(org.springframework.core.io.Resource[])
	 */
	public int loadBeanDefinitions(String location, @Nullable Set&lt;Resource&gt; actualResources) throws BeanDefinitionStoreException {
		//获取ResourceLoader对象
		ResourceLoader resourceLoader = getResourceLoader();
		if (resourceLoader == null) {
			throw new BeanDefinitionStoreException(
					&quot;Cannot load bean definitions from location [&quot; + location + &quot;]: no ResourceLoader available&quot;);
		}

		if (resourceLoader instanceof ResourcePatternResolver) {
			// Resource pattern matching available.
			try {
				//获取Resource数组，因为可能有多个Resource
				Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);
				//加载BeanDefinition
				int count = loadBeanDefinitions(resources);
				if (actualResources != null) {
					Collections.addAll(actualResources, resources);
				}
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location pattern [&quot; + location + &quot;]&quot;);
				}
				return count;
			}
			catch (IOException ex) {
				throw new BeanDefinitionStoreException(
						&quot;Could not resolve bean definition resource pattern [&quot; + location + &quot;]&quot;, ex);
			}
		}
		else {
			//获取Resource对象
			// Can only load single resources by absolute URL.
			Resource resource = resourceLoader.getResource(location);
			//加载BeanDefinition
			int count = loadBeanDefinitions(resource);
			if (actualResources != null) {
				actualResources.add(resource);
			}
			if (logger.isTraceEnabled()) {
				logger.trace(&quot;Loaded &quot; + count + &quot; bean definitions from location [&quot; + location + &quot;]&quot;);
			}
			return count;
		}
	}
</code></pre>
<ul>
<li>整体逻辑
<ul>
<li>获取ResourceLoader对象</li>
<li>根据不同的ResourceLoader执行的逻辑不同，主要是有可能存在多个Resources</li>
<li>然后调用#loadBeanDefinitions方法，所以这是一个递归的过程</li>
<li>例外获取的Resource对象或者数组都会添加到actualResources</li>
</ul>
</li>
</ul>
<h5 id="23-处理相对路径">2.3 处理相对路径</h5>
<ul>
<li>若果location是相对路径，则会根据Resource计算出对应的相对路径的Resource对象，若该Resource对象存在，调用#loadBeanDefinitions方法进行加载</li>
<li>否则，构造一个绝对location，即StringUtils.applyRelativePath(baseLocation, location)，并且调用#loadBeanDefinitions方法，与绝对路径一样</li>
</ul>
<h4 id="3-小结">3、小结</h4>
<ul>
<li>import标签的解析比较明朗，获取Resource属性值，得到正确的资源路径，然后调用#loadBeanDefinitions进行递归的BeanDefinition加载</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC 之注册 BeanDefinitions]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-zhu-ce-beandefinitions</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-zhu-ce-beandefinitions">
        </link>
        <updated>2020-03-14T08:45:49.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>获取XML DOcument对象之后，会根据该对象和Resource资源对象调用XmlBeanDefinitionReader#registerBeanDefinitions方法，开始注册BeanDefinition。</li>
</ul>
<pre><code>	public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
		//创建BeanDefinitionDocumentReader对象
		BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
		//获取之前注册的数量
		int countBefore = getRegistry().getBeanDefinitionCount();
		//创建XmlReaderContext对象，注册BeanDefinition
		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
		//返回新注册的数量
		return getRegistry().getBeanDefinitionCount() - countBefore;
	}

</code></pre>
<ul>
<li>BeanDefinitionDocumentReader 定义读取Document并注册BeanDefinition功能</li>
</ul>
<h4 id="1-createbeandefinitiondocumentreader">1、createBeanDefinitionDocumentReader</h4>
<pre><code>	private Class&lt;? extends BeanDefinitionDocumentReader&gt; documentReaderClass =
			DefaultBeanDefinitionDocumentReader.class;

	protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() {
		return BeanUtils.instantiateClass(this.documentReaderClass);
	}
</code></pre>
<h4 id="2-registerbeandefinitions">2、registerBeanDefinitions</h4>
<pre><code>public interface BeanDefinitionDocumentReader {

	/**
	 * Read bean definitions from the given DOM document and
	 * register them with the registry in the given reader context.
	 * @param doc the DOM document
	 * @param readerContext the current context of the reader
	 * (includes the target registry and the resource being parsed)
	 * @throws BeanDefinitionStoreException in case of parsing errors
	 */
	void registerBeanDefinitions(Document doc, XmlReaderContext readerContext)
			throws BeanDefinitionStoreException;

}
</code></pre>
<ul>
<li>从给定的Document对象中解析定义的BeanDefinition并将他们注册到注册表中，方法接受两个参数：
<ul>
<li>doc， 方法参数，待解析的Document对象</li>
<li>readerContent方法，解析器的当前上下文，包括目标注册表和被解析的资源。它是根据 Resource 来创建的</li>
</ul>
</li>
</ul>
<h5 id="21-defaultbeandefinitiondocumentreader">2.1 DefaultBeanDefinitionDocumentReader</h5>
<ul>
<li>BeanDefinitionDocumentReader有且只有一个实现类，DefaultBeanDefinitionDocumentReader，对于registerBeanDefinitions的实现</li>
</ul>
<pre><code>	@Nullable
	private XmlReaderContext readerContext;

	@Nullable
	private BeanDefinitionParserDelegate delegate;

    	protected void doRegisterBeanDefinitions(Element root) {
		// Any nested &lt;beans&gt; elements will cause recursion in this method. In
		// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,
		// keep track of the current (parent) delegate, which may be null. Create
		// the new (child) delegate with a reference to the parent for fallback purposes,
		// then ultimately reset this.delegate back to its original (parent) reference.
		// this behavior emulates a stack of delegates without actually necessitating one.
		//记录之前的BeanDefinitionParserDelegate
		BeanDefinitionParserDelegate parent = this.delegate;
		//创建BeanDefinitionParserDelegate对象设置给delegate
		this.delegate = createDelegate(getReaderContext(), root, parent);
		//检查&lt;beans/&gt;跟标签的命名空间是否为空，或者是http://www.springframework.org/schema/beans
		if (this.delegate.isDefaultNamespace(root)) {
			//处理profile属性
			String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);
			if (StringUtils.hasText(profileSpec)) {
				String[] specifiedProfiles = StringUtils.tokenizeToStringArray(
						profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);
				//所有的profile都无效，则不进行注册
				// We cannot use Profiles.of(...) since profile expressions are not supported
				// in XML config. See SPR-12458 for details.
				if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Skipped XML bean definition file due to specified profiles [&quot; + profileSpec +
								&quot;] not matching: &quot; + getReaderContext().getResource());
					}
					return;
				}
			}
		}
		//解析钱处理
		preProcessXml(root);
		//解析
		parseBeanDefinitions(root, this.delegate);
		//解析后处理
		postProcessXml(root);
		//设置delegate回老的BeanDefinitionParserDelegate
		this.delegate = parent;
	}

</code></pre>
<ul>
<li>创建BeanDefinitionParserDelegate对象，并设置到delegate。BeanDefinitionParserDelegate是一个重要的类，负责解析BeanDefinition，定义解析XML Element的各种方法</li>
</ul>
<pre><code>protected BeanDefinitionParserDelegate createDelegate(
			XmlReaderContext readerContext, Element root, @Nullable BeanDefinitionParserDelegate parentDelegate) {
		//创建BeanDefinitionParserDelegate对象
		BeanDefinitionParserDelegate delegate = new BeanDefinitionParserDelegate(readerContext);
		//初始化默认
		delegate.initDefaults(root, parentDelegate);
		return delegate;
	}
</code></pre>
<ul>
<li>检查<beans/>根标签的命名空间是否为空，或者是http://www.springframework.org/schema/beans
<ul>
<li>判断是否<beans/>上配置了profile属性。</li>
<li>使用分隔符切分，可能有多个profile</li>
<li>判断如果所有的profile都无效，则return不进行注册</li>
</ul>
</li>
<li>调用#parseBeanDefinitions方法，进行逻辑解析</li>
<li>解析前后的处理。目前这两个方法的实现都是空的，交由子类来实现</li>
</ul>
<pre><code>protected void preProcessXml(Element root) {}

protected void postProcessXml(Element root) {}
</code></pre>
<h5 id="221-parsebeandefinitions">2.2.1 parseBeanDefinitions</h5>
<ul>
<li>#parseBeanDefinitions方法来进行BeanDefinition的逻辑解析</li>
<li>Spring的Bean有两种声明方式
<ul>
<li>配置文件式声明：<bean id="studentService" class="org.springframework.core.StudentService" /></li>
<li>自定义注解解析： <a href="tx:annotation-driven">tx:annotation-driven</a></li>
</ul>
</li>
</ul>
<pre><code>	protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
		//如果根节点使用默认的命名空间，执行默认的解析
		if (delegate.isDefaultNamespace(root)) {
			NodeList nl = root.getChildNodes();
			//遍历子节点
			for (int i = 0; i &lt; nl.getLength(); i++) {
				Node node = nl.item(i);
				if (node instanceof Element) {
					Element ele = (Element) node;
					//判断是否使用默认命名空间，执行默认解析Element
					if (delegate.isDefaultNamespace(ele)) {
						parseDefaultElement(ele, delegate);
					}
					else {
						//执行自定义解析
						delegate.parseCustomElement(ele);
					}
				}
			}
		}
		else {
			//根节点没有使用默认的命名空间的话，也执行自定义解析
			delegate.parseCustomElement(root);
		}
	}
</code></pre>
<ul>
<li>默认的命名空间，调用#parseDefaultElement来进行解析</li>
</ul>
<pre><code>private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) {
		if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) {
			importBeanDefinitionResource(ele);
		}
		else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) {
			processAliasRegistration(ele);
		}
		else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) {
			processBeanDefinition(ele, delegate);
		}
		else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) {
			// recurse
			doRegisterBeanDefinitions(ele);
		}
	}
</code></pre>
<ul>
<li>不是默认的命名空间，调用#parseCustomElement进行解析</li>
</ul>
<h5 id="3-createreadercontext">3、createReaderContext</h5>
<ul>
<li>createReaderContext代码如下</li>
</ul>
<pre><code>	/**
	 * Create the {@link XmlReaderContext} to pass over to the document reader.
	 */
	public XmlReaderContext createReaderContext(Resource resource) {
		return new XmlReaderContext(resource, this.problemReporter, this.eventListener,
				this.sourceExtractor, this, getNamespaceHandlerResolver());
	}
</code></pre>
<h5 id="4-小结">4、小结</h5>
<ul>
<li>doLoadBeanDefinitions中做的三件事情分析完毕（获取Document，验证模型，注册BeanDefinition）</li>
<li>doLoadBeanDefinitions方法的整体时序<br>
<img src="https://guyang233.github.io/post-images/1584201819026.jpg" alt="" loading="lazy"></li>
<li>红框的部分就是BeanDefinition的解析过程</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC 之获取 Document 对象]]></title>
        <id>https://guyang233.github.io/post/hah</id>
        <link href="https://guyang233.github.io/post/hah">
        </link>
        <updated>2020-03-09T14:46:50.000Z</updated>
        <content type="html"><![CDATA[<h3 id="获取document实例">获取Document实例</h3>
<h4 id="1-documentloader">1、 DocumentLoader</h4>
<ul>
<li>定义从资源文件加载到转换为Document的功能
<ul>
<li>InputSource，加载Document的resource资源</li>
<li>EntityResolver， 解析文件的解析器</li>
<li>ErrorHandler， 处理加载Document对象的过程中的异常</li>
<li>validationMode， 校验模式</li>
<li>namespaceAware，命名空间，如果需要提供支持对XML名称空间的支持，则需要值为true</li>
</ul>
</li>
</ul>
<pre><code>public interface DocumentLoader {

	/**
	 * Load a {@link Document document} from the supplied {@link InputSource source}.
	 * @param inputSource the source of the document that is to be loaded
	 * @param entityResolver the resolver that is to be used to resolve any entities
	 * @param errorHandler used to report any errors during document loading
	 * @param validationMode the type of validation
	 * {@link org.springframework.util.xml.XmlValidationModeDetector#VALIDATION_DTD DTD}
	 * or {@link org.springframework.util.xml.XmlValidationModeDetector#VALIDATION_XSD XSD})
	 * @param namespaceAware {@code true} if support for XML namespaces is to be provided
	 * @return the loaded {@link Document document}
	 * @throws Exception if an error occurs
	 */
	Document loadDocument(
			InputSource inputSource, EntityResolver entityResolver,
			ErrorHandler errorHandler, int validationMode, boolean namespaceAware)
			throws Exception;

}1
</code></pre>
<h5 id="1-1-defaultdocumentloader">1、1 DefaultDocumentLoader</h5>
<ul>
<li>#loadDocument由DefaultDocumentLoader实现</li>
</ul>
<pre><code>//&lt;1&gt; 创建 DocumentBuilderFactory
		DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);
		}
		// &lt;2&gt; 创建 DocumentBuilder
		DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
		// &lt;3&gt; 解析 XML InputSource 返回 Document 对象
		return builder.parse(inputSource);
</code></pre>
<ul>
<li>首先调用#createDocumentBuilderFactory来创建DocumentBuilderFactory对象</li>
</ul>
<pre><code>protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware)
			throws ParserConfigurationException {
		// 创建 DocumentBuilderFactor
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		//设置命名空间支持
		factory.setNamespaceAware(namespaceAware);
		//判断是否校验禁用
		if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) {
			//开启校验
			factory.setValidating(true);
			//判断是不是XSD模式
			if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) {
				// Enforce namespace aware for XSD...
				//XSD模式下。强制将名称空间感知为XSD
				factory.setNamespaceAware(true);
				try {
					factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);
				}
				catch (IllegalArgumentException ex) {
					ParserConfigurationException pcex = new ParserConfigurationException(
							&quot;Unable to validate using XSD: Your JAXP provider [&quot; + factory +
							&quot;] does not support XML Schema. Are you running on Java 1.4 with Apache Crimson? &quot; +
							&quot;Upgrade to Apache Xerces (or Java 1.5) for full XSD support.&quot;);
					pcex.initCause(ex);
					throw pcex;
				}
			}
		}

		return factory;
	}
</code></pre>
<ul>
<li>然后调用#createDocumentBuilder方法来创建DocumentBuilder对象</li>
</ul>
<pre><code>    	protected DocumentBuilder createDocumentBuilder(DocumentBuilderFactory factory,
			@Nullable EntityResolver entityResolver, @Nullable ErrorHandler errorHandler)
			throws ParserConfigurationException {
		//创建DocumentBuilder对象
		DocumentBuilder docBuilder = factory.newDocumentBuilder();
		if (entityResolver != null) {
			//设置entityResolver属性
			docBuilder.setEntityResolver(entityResolver);
		}
		if (errorHandler != null) {
			//设置errorHandler属性
			docBuilder.setErrorHandler(errorHandler);
		}
		return docBuilder;
	}
</code></pre>
<ul>
<li>最后调用DocumentBuilder#parse 返回Document对象</li>
</ul>
<h4 id="2-entityresolver">2、EntityResolver</h4>
<ul>
<li>XmlBeanDefinitionReader#getEntityResolver方法获取的EntityResolver，返回指定的解析器，如果没有指定，则构造一个未指定的默认解析器</li>
</ul>
<pre><code>	protected EntityResolver getEntityResolver() {
		if (this.entityResolver == null) {
			// Determine default EntityResolver to use.
			ResourceLoader resourceLoader = getResourceLoader();
			if (resourceLoader != null) {
				this.entityResolver = new ResourceEntityResolver(resourceLoader);
			}
			else {
				this.entityResolver = new DelegatingEntityResolver(getBeanClassLoader());
			}
		}
		return this.entityResolver;
	}

</code></pre>
<pre><code>- resourceLoader不为null，根据ResourLoader创建一个ResourceEntityResolver
- resourceLoader为null，创建一个DelegatingEntityResolver对象，默认委托给BeansDtdResolver和PluggableSchemaResolver
</code></pre>
<h5 id="2-1-entityresolver的子类">2、1  EntityResolver的子类</h5>
<ul>
<li>BeansDtdResolver ，EntityResolver接口的实现，Spring beans DTD的解析器，用来从classpath或jar文件中加载dtd。</li>
</ul>
<pre><code>    private static final String DTD_EXTENSION = &quot;.dtd&quot;;

    private static final String DTD_NAME = &quot;spring-beans&quot;;

</code></pre>
<ul>
<li>PluggableSchemaResolver, Entity接口的实现，读取classpath下所有匹配&quot;META-INF/spring.schemas&quot;成一个schema URL 和chema path对应的map</li>
</ul>
<pre><code>    /**
        * The location of the file that defines schema mappings.
        * Can be present in multiple JAR files.
	*/
	public static final String DEFAULT_SCHEMA_MAPPINGS_LOCATION = &quot;META-INF/spring.schemas&quot;;


	private static final Log logger = LogFactory.getLog(PluggableSchemaResolver.class);

	@Nullable
	private final ClassLoader classLoader;

	//schema文件地址
	private final String schemaMappingsLocation;

	/** Stores the mapping of schema URL -&gt; local schema path. */
	@Nullable
	private volatile Map&lt;String, String&gt; schemaMappings;
</code></pre>
<ul>
<li>DelegatingEntityResolver，实现EntityResolver接口，分别代理dtd的BeansDtdResolver和xml schemas的PluggableSchemaResolver</li>
</ul>
<pre><code>	/** Suffix for DTD files. */
	public static final String DTD_SUFFIX = &quot;.dtd&quot;;

	/** Suffix for schema definition files. */
	public static final String XSD_SUFFIX = &quot;.xsd&quot;;


	private final EntityResolver dtdResolver;

	private final EntityResolver schemaResolver;

    //默认
    public DelegatingEntityResolver(@Nullable ClassLoader classLoader) {
		this.dtdResolver = new BeansDtdResolver();
		this.schemaResolver = new PluggableSchemaResolver(classLoader);
	}

    //自定义
    public DelegatingEntityResolver(EntityResolver dtdResolver, EntityResolver schemaResolver) {
		Assert.notNull(dtdResolver, &quot;'dtdResolver' is required&quot;);
		Assert.notNull(schemaResolver, &quot;'schemaResolver' is required&quot;);
		this.dtdResolver = dtdResolver;
		this.schemaResolver = schemaResolver;
	}
</code></pre>
<ul>
<li>ResourceEntityResolver，继承DelegatingEntityResolver，通过resourceLoader来解析实体的引用</li>
</ul>
<pre><code>private final ResourceLoader resourceLoader;

public ResourceEntityResolver(ResourceLoader resourceLoader) {
	super(resourceLoader.getClassLoader());
	this.resourceLoader = resourceLoader;
}
</code></pre>
<h5 id="2-2-作用">2、2 作用</h5>
<ul>
<li>EntityResolver 的作用就是，通过实现它，应用可以自定义如何寻找【验证文件】的逻辑。</li>
<li>在loadDocument方法中涉及一个参数EntityResolver，何为EntityResolver？官网这样解释：如果SAX应用程序需要实现自定义处理外部文件实体，则必须实现此接口并使用setEntityResolver方法向SAX驱动器注册一个实例。也就是说，对于解析一个XML，SAX首先读取该XML文档上的说明，根据声明去寻找对应的DTD定义，一遍对一个文档进行一个验证。默认的寻找规则，则通过网络（实现上就是声明的DTD的URI地址）来下载对应的DTD声明。并进行认证。下载的过程是一个漫长的过程，而且网络中断或者不可用时，这里会报错，就是因为相应的DTD声明没有被找到的原因。EntityResolver的作用是项目本身就可以提供一个如何寻找DTD声明的方法，即由程序寻找DTD声明的过程，在实现时直接将此文档读取并返回给SAX即可。这样就避免了通过网络来寻找相应的声明</li>
</ul>
<pre><code>public interface EntityResolver {


    /**
     * Allow the application to resolve external entities.
     *
     * &lt;p&gt;The parser will call this method before opening any external
     * entity except the top-level document entity.  Such entities include
     * the external DTD subset and external parameter entities referenced
     * within the DTD (in either case, only if the parser reads external
     * parameter entities), and external general entities referenced
     * within the document element (if the parser reads external general
     * entities).  The application may request that the parser locate
     * the entity itself, that it use an alternative URI, or that it
     * use data provided by the application (as a character or byte
     * input stream).&lt;/p&gt;
     *
     * &lt;p&gt;Application writers can use this method to redirect external
     * system identifiers to secure and/or local URIs, to look up
     * public identifiers in a catalogue, or to read an entity from a
     * database or other input source (including, for example, a dialog
     * box).  Neither XML nor SAX specifies a preferred policy for using
     * public or system IDs to resolve resources.  However, SAX specifies
     * how to interpret any InputSource returned by this method, and that
     * if none is returned, then the system ID will be dereferenced as
     * a URL.  &lt;/p&gt;
     *
     * &lt;p&gt;If the system identifier is a URL, the SAX parser must
     * resolve it fully before reporting it to the application.&lt;/p&gt;
     *
     * @param publicId The public identifier of the external entity
     *        being referenced, or null if none was supplied.
     * @param systemId The system identifier of the external entity
     *        being referenced.
     * @return An InputSource object describing the new input source,
     *         or null to request that the parser open a regular
     *         URI connection to the system identifier.
     * @exception org.xml.sax.SAXException Any SAX exception, possibly
     *            wrapping another exception.
     * @exception java.io.IOException A Java-specific IO exception,
     *            possibly the result of creating a new InputStream
     *            or Reader for the InputSource.
     * @see org.xml.sax.InputSource
     */
    public abstract InputSource resolveEntity (String publicId,
                                               String systemId)
        throws SAXException, IOException;

}
</code></pre>
<ul>
<li>
<p>接口方法接受两个参数publicId和systemId，并且返回InputSource对象。两个参数声明如下：</p>
<ul>
<li>publicId：被引用的外部实体的公共标识符，如果没有提供，则返回null</li>
<li>systemId：被引用的外部实体的系统不是福</li>
</ul>
</li>
<li>
<p>这两个参数的实际内容和具体的验证模式的关系如下</p>
<ul>
<li>
<p>XSD验证模式</p>
<ul>
<li>publicId：null</li>
<li>systemId：http://www.springframework.org/schema/beans/spring-beans.xsd</li>
</ul>
</li>
<li>
<p>DTD验证模式</p>
<ul>
<li>publicId：-//SPRING//DTD BEAN 2.0//EN</li>
<li>systemId：http://www.springframework.org/dtd/spring-beans.dtd</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="2-3-delegatingentityresolver">2、3 DelegatingEntityResolver</h5>
<ul>
<li>Spring中使用DelegatingEntityResolver为EntityResolver的实现类
<ul>
<li>如果是DTD验证模式，使用BeansDtdResolver来进行解析</li>
<li>如果是XSD验证模式，使用PluggableSchemaResolver来进行解析</li>
</ul>
</li>
</ul>
<pre><code>	@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId)
			throws SAXException, IOException {
		//DTD验证模式
		if (systemId != null) {
			if (systemId.endsWith(DTD_SUFFIX)) {
				return this.dtdResolver.resolveEntity(publicId, systemId);
			}
			//XSD验证模式
			else if (systemId.endsWith(XSD_SUFFIX)) {
				return this.schemaResolver.resolveEntity(publicId, systemId);
			}
		}

		// Fall back to the parser's default behavior.
		return null;
	}
</code></pre>
<h5 id="2-4-beansdtdresolver">2、 4 BeansDtdResolver</h5>
<pre><code>
	@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws IOException {
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Trying to resolve XML entity with public ID [&quot; + publicId +
					&quot;] and system ID [&quot; + systemId + &quot;]&quot;);
		}
		//必须是DTD结尾
		if (systemId != null &amp;&amp; systemId.endsWith(DTD_EXTENSION)) {
			//获取最后一个“/”的位置
			int lastPathSeparator = systemId.lastIndexOf('/');
			//获取spring-beans的位置
			int dtdNameStart = systemId.indexOf(DTD_NAME, lastPathSeparator);
			if (dtdNameStart != -1) {//找到
				String dtdFile = DTD_NAME + DTD_EXTENSION;
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Trying to locate [&quot; + dtdFile + &quot;] in Spring jar on classpath&quot;);
				}
				try {
					//创建ClassPathResource
					Resource resource = new ClassPathResource(dtdFile, getClass());
					//创建InputSource对象，兵器设置publicId， systemId
					InputSource source = new InputSource(resource.getInputStream());
					source.setPublicId(publicId);
					source.setSystemId(systemId);
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Found beans DTD [&quot; + systemId + &quot;] in classpath: &quot; + dtdFile);
					}
					return source;
				}
				catch (FileNotFoundException ex) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Could not resolve beans DTD [&quot; + systemId + &quot;]: not found in classpath&quot;, ex);
					}
				}
			}
		}
		//使用默认的行为，从网络上下载
		// Fall back to the parser's default behavior.
		return null;
	}
</code></pre>
<ul>
<li>BeansDtdResolver解析DTD的过程，只是对systemId进行了简单的校验，然后构造InputSource对象，设置publicId和systemId</li>
</ul>
<h5 id="2-5-pluggableschemaresolver">2、 5 PluggableSchemaResolver</h5>
<pre><code>@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId) throws IOException {
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Trying to resolve XML entity with public id [&quot; + publicId +
					&quot;] and system id [&quot; + systemId + &quot;]&quot;);
		}

		if (systemId != null) {
			//获取Resource 所在的位置
			String resourceLocation = getSchemaMappings().get(systemId);
			if (resourceLocation == null &amp;&amp; systemId.startsWith(&quot;https:&quot;)) {
				// Retrieve canonical http schema mapping even for https declaration
				resourceLocation = getSchemaMappings().get(&quot;http:&quot; + systemId.substring(6));
			}
			if (resourceLocation != null) {
				//创建ClassPathResource对象
				Resource resource = new ClassPathResource(resourceLocation, this.classLoader);
				try {
					//创建InputSource对象。设置publicId和systemId
					InputSource source = new InputSource(resource.getInputStream());
					source.setPublicId(publicId);
					source.setSystemId(systemId);
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Found XML schema [&quot; + systemId + &quot;] in classpath: &quot; + resourceLocation);
					}
					return source;
				}
				catch (FileNotFoundException ex) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Could not find XML schema [&quot; + systemId + &quot;]: &quot; + resource, ex);
					}
				}
			}
		}

		// Fall back to the parser's default behavior.
		return null;
	}
</code></pre>
<ul>
<li>首先调用getSchemaMappings().get(systemId)，获取映射表来获取资源的位置</li>
</ul>
<pre><code>	/**
	 * Load the specified schema mappings lazily.
	 */
	private Map&lt;String, String&gt; getSchemaMappings() {
		Map&lt;String, String&gt; schemaMappings = this.schemaMappings;
		//双重检查锁，实现schemaMappings的单例
		if (schemaMappings == null) {
			synchronized (this) {
				schemaMappings = this.schemaMappings;
				if (schemaMappings == null) {
					if (logger.isTraceEnabled()) {
						logger.trace(&quot;Loading schema mappings from [&quot; + this.schemaMappingsLocation + &quot;]&quot;);
					}
					try {
						// 以 Properties 的方式，读取 schemaMappingsLocation
						Properties mappings =
								PropertiesLoaderUtils.loadAllProperties(this.schemaMappingsLocation, this.classLoader);
						if (logger.isTraceEnabled()) {
							logger.trace(&quot;Loaded schema mappings: &quot; + mappings);
						}
						//将mappings初始化到schemaMappings
						schemaMappings = new ConcurrentHashMap&lt;&gt;(mappings.size());
						CollectionUtils.mergePropertiesIntoMap(mappings, schemaMappings);
						this.schemaMappings = schemaMappings;
					}
					catch (IOException ex) {
						throw new IllegalStateException(
								&quot;Unable to load schema mappings from location [&quot; + this.schemaMappingsLocation + &quot;]&quot;, ex);
					}
				}
			}
		}
		return schemaMappings;
	}
</code></pre>
<ul>
<li>部分映射表<br>
<img src="https://guyang233.github.io/post-images/1584172944557.png" alt="" loading="lazy"></li>
<li>然后根据传入的systemId来获取映射表对应文件的位置</li>
<li>最后根据resourceLocation来构造InputSource对象，设置publicId和systemId</li>
</ul>
<h5 id="2-6-resourceentityresolver">2、 6 ResourceEntityResolver</h5>
<pre><code>@Override
	@Nullable
	public InputSource resolveEntity(@Nullable String publicId, @Nullable String systemId)
			throws SAXException, IOException {
		//调用父类的方法
		InputSource source = super.resolveEntity(publicId, systemId);
		//解析失败，使用resourceLoader来解析。通过对systemId的解码操作来获取文件资源的位置，通过resourceLoader来获取Resource对应，设置publicId和systemId
		if (source == null &amp;&amp; systemId != null) {
			String resourcePath = null;
			try {
				String decodedSystemId = URLDecoder.decode(systemId, &quot;UTF-8&quot;);
				String givenUrl = new URL(decodedSystemId).toString();
				String systemRootUrl = new File(&quot;&quot;).toURI().toURL().toString();
				// Try relative to resource base if currently in system root.
				if (givenUrl.startsWith(systemRootUrl)) {
					resourcePath = givenUrl.substring(systemRootUrl.length());
				}
			}
			catch (Exception ex) {
				// Typically a MalformedURLException or AccessControlException.
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Could not resolve XML entity [&quot; + systemId + &quot;] against system root URL&quot;, ex);
				}
				// No URL (or no resolvable URL) -&gt; try relative to resource base.
				resourcePath = systemId;
			}
			if (resourcePath != null) {
				if (logger.isTraceEnabled()) {
					logger.trace(&quot;Trying to locate XML entity [&quot; + systemId + &quot;] as resource [&quot; + resourcePath + &quot;]&quot;);
				}
				Resource resource = this.resourceLoader.getResource(resourcePath);
				source = new InputSource(resource.getInputStream());
				source.setPublicId(publicId);
				source.setSystemId(systemId);
				if (logger.isDebugEnabled()) {
					logger.debug(&quot;Found XML entity [&quot; + systemId + &quot;]: &quot; + resource);
				}
			}
			else if (systemId.endsWith(DTD_SUFFIX) || systemId.endsWith(XSD_SUFFIX)) {
				// External dtd/xsd lookup via https even for canonical http declaration
				String url = systemId;
				if (url.startsWith(&quot;http:&quot;)) {
					url = &quot;https:&quot; + url.substring(5);
				}
				try {
					source = new InputSource(new URL(url).openStream());
					source.setPublicId(publicId);
					source.setSystemId(systemId);
				}
				catch (IOException ex) {
					if (logger.isDebugEnabled()) {
						logger.debug(&quot;Could not resolve XML entity [&quot; + systemId + &quot;] through URL [&quot; + url + &quot;]&quot;, ex);
					}
					// Fall back to the parser's default behavior.
					source = null;
				}
			}
		}

		return source;
	}
</code></pre>
<ul>
<li>首先调用父类的方法来解析</li>
<li>如果父类解析失败，则使用ResourceLoader来对systemId对应的Resouce进行读取</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC之获取验证模型]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-huo-qu-yan-zheng-mo-xing</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-huo-qu-yan-zheng-mo-xing">
        </link>
        <updated>2020-03-09T13:35:09.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>IoC加载定义核心方法是#doLoadDocument方法中主要做三件事
<ul>
<li>1、调用#getValidationModeForResource方法，获取指定资源（xml）的验证模式</li>
<li>2、调用DocumentLoader#loadDocument方法，获取XML Document实例</li>
<li>3、调用#registerBeanDefinitions方法，根据获取的文档实例，注册Bean信息</li>
<li>4、主要是分析第一步，获取XML文件的验证模式。为什么要获取验证模式呢？原因主要是：XML文件的验证模式保证了XML文件的正确性</li>
</ul>
</li>
</ul>
<h4 id="1-dtd与xsd的区别">1、 DTD与XSD的区别</h4>
<ul>
<li>1、DTD
<ul>
<li>DTD（文档类型定义），即文档类型定义，为XML文件的验证机制，属于XML文件中组成的部分。DTD是一种保证XML文档格式正确的有效验证方式，它定义了相关XML文档的元素，实际上DTD就相当于XML中的“词汇”和“语法”，我们可以通过比较XML文件和DTD文件来看文档是否符合规范，元素和标签。使用是否正确</li>
<li>要在Spring中使用DTD，需要在Spring XML文件标题中声明</li>
</ul>
</li>
</ul>
<pre><code>&lt;？xml version =“ 1.0” encoding =“ UTF-8”？&gt; 
&lt;！DOCTYPE bean PUBLIC“-// SPRING // DTD BEAN // EN”“ http://www.springframework.org/dtd/spring- beans.dtd“&gt;
</code></pre>
<pre><code>-  DTD在一定阶段推动了XML得发展，本身存在着一些缺陷
    - 1、没有使用XML格式，而是自己定义的一套格式，相对解析器的重用性较差；而且DTD的内置和访问没有标准的编程接口，因此解析器很难简单的解析DTD文档
    - 2、DTD对元素的类型限制上限；同时其他的约束力也较弱
    - 3、DTD扩展能力较差
    - 4、基于正则表达式的DTD文档的描述能力有限
</code></pre>
<ul>
<li>2、XSD
<ul>
<li>针对DTD的缺陷，W3C在2001年推出XSD。XSD（XML模式定义）即XML模式语言。XML模式本身就是一个XML文档，使用的就是XML语法，因此可以很方便的解析XSD文档。相对于DTD，XSD具有如下优势
<ul>
<li>1、XML模式基于XML，没有专门的语法</li>
<li>2、XML架构可以像其他XML文件一样的解析和处理</li>
<li>3、XML Schema比DTD提供了丰富的数据模型</li>
<li>4、XML模式提供可扩展的数据模型</li>
<li>5、XML Schema支持综合命名空间</li>
<li>6、XML模式支持属性组</li>
<li></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-getvalidationmodeforresource">2、 getValidationModeForResource</h4>
<pre><code>	/**
	 * Indicates that the validation should be disabled.
	 */
	//禁用验证模式
	public static final int VALIDATION_NONE = XmlValidationModeDetector.VALIDATION_NONE;

	/**
	 * Indicates that the validation mode should be detected automatically.
	 */
	//自动校验模式
	public static final int VALIDATION_AUTO = XmlValidationModeDetector.VALIDATION_AUTO;

	/**
	 * Indicates that DTD validation should be used.
	 */
	//DTD校验模式
	public static final int VALIDATION_DTD = XmlValidationModeDetector.VALIDATION_DTD;

	/**
	 * Indicates that XSD validation should be used.
	 */
	//XSD验证模式
	public static final int VALIDATION_XSD = XmlValidationModeDetector.VALIDATION_XSD;

	/**
	 * 验证模式。默认为自动模式
	 */
	private int validationMode = VALIDATION_AUTO;

    protected int getValidationModeForResource(Resource resource) {
		//&lt;1&gt;、获取指定的验证模式
		int validationModeToUse = getValidationMode();
		//首先，如果手动指定，则直接返回
		if (validationModeToUse != VALIDATION_AUTO) {
			return validationModeToUse;
		}
		//&lt;2&gt;、 其次，自动获取验证模式
		int detectedMode = detectValidationMode(resource);
		if (detectedMode != VALIDATION_AUTO) {
			return detectedMode;
		}
		// 最后，使用 VALIDATION_XSD 做为默认
		// Hmm, we didn't get a clear indication... Let's assume XSD,
		// since apparently no DTD declaration has been found up until
		// detection stopped (before finding the document's root tag).
		return VALIDATION_XSD;
	}
</code></pre>
<ul>
<li>在&lt;1&gt;处，调用#getValidationMode方法，获取指定的验证模式。如果没有手动指定，则直接返回。另外，对于属性的设置和获得的代码。代码如下：</li>
</ul>
<pre><code>public void setValidationMode(int validationMode) {
	this.validationMode = validationMode;
}

public int getValidationMode() {
	return this.validationMode;
}
</code></pre>
<ul>
<li>&lt;2&gt;处，调用#detectValidationMode方法，自动获取验证模式</li>
</ul>
<pre><code>//XML 验证模式探测器
private final XmlValidationModeDetector validationModeDetector = new XmlValidationModeDetector();

protected int detectValidationMode(Resource resource) {
		//不可读，抛出异常
		if (resource.isOpen()) {
			throw new BeanDefinitionStoreException(
					&quot;Passed-in Resource [&quot; + resource + &quot;] contains an open stream: &quot; +
					&quot;cannot determine validation mode automatically. Either pass in a Resource &quot; +
					&quot;that is able to create fresh streams, or explicitly specify the validationMode &quot; +
					&quot;on your XmlBeanDefinitionReader instance.&quot;);
		}
		//打开InputStream流
		InputStream inputStream;
		try {
			inputStream = resource.getInputStream();
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(
					&quot;Unable to determine validation mode for [&quot; + resource + &quot;]: cannot open InputStream. &quot; +
					&quot;Did you attempt to load directly from a SAX InputSource without specifying the &quot; +
					&quot;validationMode on your XmlBeanDefinitionReader instance?&quot;, ex);
		}

		try {
			//&lt;X&gt;获取相应的验证模式
			return this.validationModeDetector.detectValidationMode(inputStream);
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(&quot;Unable to determine validation mode for [&quot; +
					resource + &quot;]: an error occurred whilst reading from the InputStream.&quot;, ex);
		}
	}
</code></pre>
<pre><code>- 核心在于&lt;X&gt;处，调用XmlValidationModeDetector#detectValidationMode方法，获取相应的验证模式。
</code></pre>
<ul>
<li>最后使用VALIDATION_XSD 作为默认</li>
</ul>
<h4 id="3-xmlvalidationmodedetector">3、XmlValidationModeDetector</h4>
<ul>
<li>XmlValidationModeDetector，XML验证器模式探测器</li>
</ul>
<pre><code>public int detectValidationMode(InputStream inputStream) throws IOException {
		// Peek into the file to look for DOCTYPE.
		BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));
		try {
			//是否为DTD校验模式，默认为非DTD模式，即XSD模式
			boolean isDtdValidated = false;
			String content;
			// &lt;0&gt; 循环，逐行读取 XML 文件的内容
			while ((content = reader.readLine()) != null) {
				content = consumeCommentTokens(content);
				// 跳过，如果是注释，或者
				if (this.inComment || !StringUtils.hasText(content)) {
					continue;
				}
				// &lt;1&gt; 包含 DOCTYPE 为 DTD 模式
				if (hasDoctype(content)) {
					isDtdValidated = true;
					break;
				}
				// &lt;2&gt;  hasOpeningTag 方法会校验，如果这一行有 &lt; ，并且 &lt; 后面跟着的是字母，则返回 true 。
				if (hasOpeningTag(content)) {
					// End of meaningful data...
					break;
				}
			}
			// 返回 VALIDATION_DTD or VALIDATION_XSD 模式
			return (isDtdValidated ? VALIDATION_DTD : VALIDATION_XSD);
		}
		catch (CharConversionException ex) {
			// &lt;3&gt; 返回 VALIDATION_AUTO 模式
			// Choked on some character encoding...
			// Leave the decision up to the caller.
			return VALIDATION_AUTO;
		}
		finally {
			reader.close();
		}
	}
</code></pre>
<ul>
<li>&lt;0&gt;处，从代码看，主要是通过读取XML文件的内容，来自动判断</li>
<li>&lt;1&gt;处，调用#hasDoctype方法，判断内容中如果包含有“DOCTYPE”，则为DTD验证模式。</li>
</ul>
<pre><code>	private static final String DOCTYPE = &quot;DOCTYPE&quot;;

	/**
	 * Does the content contain the DTD DOCTYPE declaration?
	 */
	private boolean hasDoctype(String content) {
		return content.contains(DOCTYPE);
	}
</code></pre>
<ul>
<li>&lt;2&gt;处，调用#hasOpeningTag方法，判断如果这一行包含&lt;,并且&lt;紧跟着的是字母，则为XSD验证模式</li>
</ul>
<pre><code>	private boolean hasOpeningTag(String content) {
		if (this.inComment) {
			return false;
		}
		int openTagIndex = content.indexOf('&lt;');// &lt;存在
		return (openTagIndex &gt; -1 &amp;&amp; (content.length() &gt; openTagIndex + 1) &amp;&amp; // &lt; 后面还有内容
				Character.isLetter(content.charAt(openTagIndex + 1))); // &lt; 后面的内容是字母
	}
</code></pre>
<ul>
<li>&lt;3&gt;处，如果发生CharConversionException异常，则为VALIDATION_AUTO模式</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC之加载BeanDefinition]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-jia-zai-beandefinition</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-jia-zai-beandefinition">
        </link>
        <updated>2020-03-01T14:21:40.000Z</updated>
        <content type="html"><![CDATA[<pre><code>ClassPathResource resource = new ClassPathResource(&quot;bean.xml&quot;); // &lt;1&gt;
DefaultListableBeanFactory factory = new DefaultListableBeanFactory(); // &lt;2&gt;
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory); // &lt;3&gt;
reader.loadBeanDefinitions(resource); // &lt;4&gt;
</code></pre>
<ul>
<li>这段代码是Spring编程式中使用IoC容器，可以判断IoC容器的使用过程
<ul>
<li>获取资源</li>
<li>创建BeanFactory</li>
<li>根据新创建的BeanFactory创建一个BeanDefinitionReader对象，该reader对象为资源解析器</li>
<li>装载资源</li>
</ul>
</li>
<li>整个过程分为三个步骤，资源定位、装载、注册
<ul>
<li>资源定位：我们一般用外部资源来描述Bean对象，所以在初始化IoC容器的第一步就是要定位外部资源。</li>
<li>装载：装载就是BeanDefinition的载入，BeanDefinitionReader读取、解析Resource资源，也就是将用户定义的Bean表示成为IoC容器的内部数据结构，BeanDefinition</li>
<li>在IoC容器内部中维护着一个BeanDefinitionMap的数据结构</li>
<li>在配置文件中每一个<bean>都对应着一个BeanDefinition对象。BeanDefinitionReader，主要定义资源文件读取并转换为BeanDefinition的各个功能</li>
<li>注册：向IoC容器注册在第二步解析好的BeanDefinition，这个过程是通过BeanDefinitionRegistry接口实现的，在IoC容器内部其实就是将第二过程解析得到的BeanDefinition注入到一个 HashMap容器中，IoC容器就是通过这个HashMap来维护这些BeanDefinition的</li>
<li><img src="https://guyang233.github.io/post-images/1583108382024.png" alt="" loading="lazy">
<ul>
<li>在这里需要注意的一点是这个过程中并没有完成依赖注入（Bean创建），Bean创建是发生在应用的第一次调用#getBean方法，想容器索要Bean时</li>
<li>当然我们饿可以通过设置预处理，即对某个Bean设置lazyinit = false属性，那么这个Bean的依赖注入就会在容器初始化的时候完成</li>
<li>简单的说，其实上面的步骤的结果就是：XML Resource =&gt; XML Document =&gt; XML BeanDefinition</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-loadbeandefinitions">1、loadBeanDefinitions</h4>
<ul>
<li>资源定位之前说过，直接分析加载，<code>reader.loadBeanDefinitions(resource);</code>这句代码才是加载资源的真正实现，所以直接从该方法下手。</li>
</ul>
<pre><code>@Override
public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException {
		return loadBeanDefinitions(new EncodedResource(resource));
	}
</code></pre>
<ul>
<li>从指定的XML文件中加载Bean Definition，这里先会对reource 资源封装成EncodedResource对象，为什么需要封装成为EncodedResource呢，主要是为了对Resource进行编码，保证内容读取的正确性。</li>
<li>然后又调用#loadBeanDefinitions方法来实现真正的逻辑</li>
</ul>
<pre><code>public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
		Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);
		if (logger.isTraceEnabled()) {
			logger.trace(&quot;Loading XML bean definitions from &quot; + encodedResource);
		}
		//1、获取已经加载过得资源
		Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();
		if (currentResources == null) {
			currentResources = new HashSet&lt;&gt;(4);
			this.resourcesCurrentlyBeingLoaded.set(currentResources);
		}
		//将当前资源添加进去，如果资源已经存在，抛出异常
		if (!currentResources.add(encodedResource)) {
			throw new BeanDefinitionStoreException(
					&quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);
		}
		try {
			//2、从 EncodedResource 获取封装的 Resource ，并从 Resource 中获取其中的 InputStream
			InputStream inputStream = encodedResource.getResource().getInputStream();
			try {
				InputSource inputSource = new InputSource(inputStream);
				if (encodedResource.getEncoding() != null) {
					inputSource.setEncoding(encodedResource.getEncoding());
				}
				//执行加载
				return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
			}
			finally {
				inputStream.close();
			}
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(
					&quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);
		}
		finally {
			//3、从缓存中剔除资源
			currentResources.remove(encodedResource);
			if (currentResources.isEmpty()) {
				this.resourcesCurrentlyBeingLoaded.remove();
			}
		}
	}
</code></pre>
<ul>
<li>1、 通过resourcesCurrentlyBeingLoaded.get()来获取已经加载过的资源，然后将encodedResource加入其中，如果已经存在该资源，抛出异常
<ul>
<li>为什么要这样做呢？Detected cyclic loading ，避免一个encodedResource在加载中，没有加载完成的时候又加载自身，从而导致死循环。</li>
<li>因此在3的步骤时，资源加载完成后，要从缓存中剔除资源</li>
</ul>
</li>
<li>2、 从EncodedResource获取封装的Resource资源，并从Resource中获取相应的InputStream，然后将InputStream封装为InputSource，最后调用#doLoadBeanDefinitions，执行整整的Bean Definition加载逻辑。</li>
</ul>
<pre><code>protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource)
			throws BeanDefinitionStoreException {

		try {
            //获取XML DOCUMENT实例
			Document doc = doLoadDocument(inputSource, resource);
            //根据Document实例注册Bean信息
			int count = registerBeanDefinitions(doc, resource);
			if (logger.isDebugEnabled()) {
				logger.debug(&quot;Loaded &quot; + count + &quot; bean definitions from &quot; + resource);
			}
			return count;
		}
		catch (BeanDefinitionStoreException ex) {
			throw ex;
		}
		catch (SAXParseException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					&quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);
		}
		catch (SAXException ex) {
			throw new XmlBeanDefinitionStoreException(resource.getDescription(),
					&quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);
		}
		catch (ParserConfigurationException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;Parser configuration exception parsing XML from &quot; + resource, ex);
		}
		catch (IOException ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;IOException parsing XML document from &quot; + resource, ex);
		}
		catch (Throwable ex) {
			throw new BeanDefinitionStoreException(resource.getDescription(),
					&quot;Unexpected exception parsing XML document from &quot; + resource, ex);
		}
	}
</code></pre>
<ul>
<li>在1处，调用doLoadDocument方法， 根据XML文件获取Document实例</li>
<li>在2处，调用registerBeanDefinitions方法，根据Document来注册Bean Definition</li>
</ul>
<pre><code>/**
 * 获取 XML Document 实例
 *
 * Actually load the specified document using the configured DocumentLoader.
 * @param inputSource the SAX InputSource to read from
 * @param resource the resource descriptor for the XML file
 * @return the DOM Document
 * @throws Exception when thrown from the DocumentLoader
 * @see #setDocumentLoader
 * @see DocumentLoader#loadDocument
 */
protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception {
	return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,
			getValidationModeForResource(resource), isNamespaceAware());
}
</code></pre>
<ul>
<li>1、调用 #getValidationModeForResource(Resource resource) 方法，获取指定资源（xml）的验证模式</li>
<li>2、调用 DocumentLoader#loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) 方法，获取 XML Document 实例</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二叉树遍历]]></title>
        <id>https://guyang233.github.io/post/er-cha-shu-bian-li</id>
        <link href="https://guyang233.github.io/post/er-cha-shu-bian-li">
        </link>
        <updated>2020-01-14T08:51:11.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-深度遍历">1、深度遍历</h3>
<ul>
<li>前序：根结点-----左子树-----右子树</li>
<li>中序：左子树-----根结点-----右子树</li>
<li>后序：左子树-----右子树-----根结点</li>
</ul>
<h3 id="2-广度遍历">2、广度遍历</h3>
<ul>
<li>层次遍历：只需要按照层次遍历即可</li>
</ul>
<h3 id="3-示例">3、示例</h3>
<figure data-type="image" tabindex="1"><img src="https://guyang233.github.io/post-images/1578992143214.png" alt="" loading="lazy"></figure>
<ul>
<li>前序遍历：1、2、4、5、 7、 8、 3、 6
<ul>
<li>递归遍历</li>
</ul>
<pre><code>/**
 * 前序遍历
 */
public void preOrderTraversal(TreeNode root){
    if (root != null){
        System.out.println(root.value);
        preOrderTraversal(root.getLeft());
        preOrderTraversal(root.getRight());
    }
}
</code></pre>
<ul>
<li>非递归遍历</li>
</ul>
<pre><code>/**
 * 前序遍历2，非递归
 * 优先访问根结点，然后访问左子树和右子树
 * 当左子树不为空的时候，重复
 * 当左子树为空的时候，切换为右子树
 */
public void preOrderTraversal2(TreeNode root){
    LinkedList&lt;TreeNode&gt; linkedList = new LinkedList&lt;&gt;();
    TreeNode pNode = root;
    while(pNode != null || !linkedList.isEmpty()){
        if (pNode !=null){
            System.out.println(pNode.value);
            linkedList.push(pNode);
            pNode = pNode.left;
        } else {
            TreeNode node = linkedList.pop();
            pNode = node.right;
        }
    }
}
</code></pre>
</li>
<li>中序遍历：4、 2、 7、 5、 8、 1、 3、 6
<ul>
<li>递归遍历</li>
</ul>
<pre><code>/**
 * 递归中序遍历
 */
public void midOrderTraversal(TreeNode root){
    if (root != null){
        midOrderTraversal(root.getLeft());
        System.out.println(root.value);
        midOrderTraversal(root.getRight());
    }
}
</code></pre>
<ul>
<li>非递归遍历</li>
</ul>
<pre><code>/**
 * 非递归前序遍历
 * 1、先是不断的去寻找左子树
 * 2、找到最左的第一个孩子没有左子树的结点
 * 3、输出节点（父结点的值），并且遍历该结点的右孩子
 * 4、遍历完右孩子之后，stack.pop()，是该结点的父结点
 * 5、重复上述步骤
 */
public void midOrderTraversal2(TreeNode root){
   LinkedList&lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();
   TreeNode pNode = root;
   while (pNode !=null || !stack.isEmpty()){
       if (pNode != null){
           stack.push(pNode);
           pNode = pNode.left;
       } else {
           TreeNode node = stack.pop();
           System.out.println(node.value);
           pNode = node.right;
       }
   }
}
</code></pre>
<ul>
<li>后序遍历：4、 7、 8、 5、 2、 6、 3、 1
<ul>
<li>递归遍历</li>
</ul>
<pre><code>/**
 * 递归后序遍历
 */
public void postOrderTraversal(TreeNode root){
    if (root != null){
        midOrderTraversal(root.getLeft());
        midOrderTraversal(root.getRight());
        System.out.println(root.value);
    }
}
</code></pre>
<ul>
<li>非递归遍历</li>
</ul>
<pre><code> /**
 * 递归后序遍历
 * 1、借助两个stack来实现
 * 2、判断root是否为空，不为空的话压入stack2
 * 3、判断左右子树，不为空的话压入stack1，压入的顺序是：左-&gt;右
 * 4、从stack1中按照先压入根，然后压入左，最后压入右
 * 5、逻辑中，根结点先被压入stack2中，然后从stack1中弹出右，压入stack2中，最后弹出左，压入stack2中，stack2中的顺序为：根-右-左
 * 6、依次弹出stack2中的结点。按照左-右-根的顺序
 */
public void postOrderTraversal2(TreeNode root){
   if (root != null){
       LinkedList&lt;TreeNode&gt; stack1 = new LinkedList&lt;&gt;();
       LinkedList&lt;TreeNode&gt; stack2 = new LinkedList&lt;&gt;();
       stack1.push(root);
       while (!stack1.isEmpty()){
           root = stack1.pop();
           stack2.push(root);
           if (root.left != null){
               stack1.push(root.left);
           }
           if (root.right != null){
               stack1.push(root.right);
           }
       }
       while (!stack2.isEmpty()){
           System.out.println(stack2.pop().value);
       }
   }
}
</code></pre>
</li>
</ul>
</li>
<li>层次遍历</li>
</ul>
<pre><code>/**
     * 层次遍历
     * 1、先将root结点放进队列，出队列输出
     * 2、将不为空的左右子树放进队列，出队列输出
     * @param root 根结点
     */
    public void levelTraverse(TreeNode root){
        TreeNode node;
        if (root != null){
            //初始化队列
            LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();
            //根结点入队列
            queue.offer(root);
            while(!queue.isEmpty()){
                //出队列
                node = queue.poll();
                System.out.println(node.value);
                //左节点入队列
                if (node.left != null){
                    queue.offer(node.left);
                }
                //右节点入队列
                if (node.right != null){
                    queue.offer(node.right);
                }
            }
        }
    }
</code></pre>
<h3 id="4-二叉树的构建">4、二叉树的构建</h3>
<ul>
<li>前序遍历和中序遍历构建二叉树</li>
<li>中序遍历和后续遍历构建二叉树</li>
</ul>
<pre><code>/**
     *      * 1、前序和后序能够直接确定根节点
     *      * 2、然后根据中序遍历能够确定左右子树
     *      * 3、根据前序和后序能够确定左右子树的根结点
     *      * 4、递归重复上述步骤
     *      *
     *      * 由前序遍历和中序遍历，或后序遍历和中序遍历推导简历二叉树
     *      * @param preOrder 前序遍历的序列
     *      * @param midOrder 中序遍历的序列
     *      * @param preIndex 前序遍历开始位置
     *      * @param midIndex 中序遍历开始位置
     *      * @param count 节点数
     */
    public TreeNode(String preOrder, String midOrder, int preIndex, int midIndex, int count){
        if (count &gt; 0){
            //获取前序遍历根节点
            char r = preOrder.charAt(preIndex);
            //记录根结点在中序遍历序列的位置
            int i = 0;
            for (; i &lt; count; i++){
                if (r == midOrder.charAt(i)){
                    break;
                }
            }
            TreeNode node = new TreeNode(Integer.parseInt(String.valueOf(r)));
            //递归构造左右子树
            node.left = new TreeNode(preOrder, midOrder, preIndex + 1, midIndex, i);
            node.right = new TreeNode(preOrder, midOrder, preIndex + i +1, midIndex + i + 1, count - i -1);
        }
    }
</code></pre>
<ul>
<li>完全二叉树的层次序列构建二叉树</li>
</ul>
<pre><code>   /**
     * 完全二叉树的层次序列构建二叉树
     * @param order 层次序列
     * @param index 根结点位置
     */
    public TreeNode(String order, Integer index){
        if (index &lt; order.length()){
            TreeNode node = new TreeNode((int) order.charAt(index));
            //建立左右子树
            node.left = new TreeNode(order, 2 * index + 1);
            node.right = new TreeNode(order, 2 * index + 2);
        }
    }
</code></pre>
<ul>
<li>标明空子树的前序序列构建二叉树</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构-二叉树]]></title>
        <id>https://guyang233.github.io/post/shu-ju-jie-gou-er-cha-shu</id>
        <link href="https://guyang233.github.io/post/shu-ju-jie-gou-er-cha-shu">
        </link>
        <updated>2020-01-13T08:03:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-简介">1、简介</h3>
<ul>
<li>什么是二叉树
<ul>
<li>本身是有序树</li>
<li>树中包含各个结点的度不能超过2，即只能是0,1,2<br>
<img src="https://guyang233.github.io/post-images/1578902741017.gif" alt="" loading="lazy"></li>
</ul>
<h3 id="2-叉树的性质">2、叉树的性质</h3>
<ul>
<li>二叉树中，第i层最多有2的（i-1）次幂个结点</li>
<li>如果二叉树的深度为K，那么此二叉树最多有2的K次幂减1个结点</li>
<li>二叉树中，终端节点数（叶子节点数）为n0，度为2的结点数为n2，则n0 = n2 + 1。</li>
</ul>
</li>
</ul>
<pre><code>对于一个二叉树来说，除了度为0的叶子节点和度为2的结点，剩下的就是度为1的结点，那么总结点n = n0
+n1+n2。同时，对于每一个结点来说都是父结点分支表示的，假设数中分枝数为B，那么总结点数n 
= B+1。而分枝数是可以通过n1和n2表示的，即 B=n1+2*n2。所以，n 用另外一种方式表示为 
n=n1+2*n2+1。 两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。
</code></pre>
<h3 id="3-满二叉树">3、满二叉树</h3>
<ul>
<li>如果二叉树中除了叶子节点，每个结点的度都为2，则此二叉树称为满二叉树<br>
<img src="https://guyang233.github.io/post-images/1578904931478.gif" alt="" loading="lazy"></li>
<li>满二叉树除了满足普通二叉树的性质，又具备以下性质：
<ul>
<li>满二叉树中第i层的结点数为2的n-1次幂</li>
<li>深度为K的满二叉树必有2的k次幂减1个结点，叶子数为2的k-1次幂</li>
<li>满二叉树中不存在度为1额结点，每一个分支点中都有两颗深度相同的子树，且叶子节点都在最底层</li>
<li>具有n个结点的满二叉树的深度为log2(n+1)。</li>
</ul>
</li>
</ul>
<h3 id="4-完全二叉树">4、完全二叉树</h3>
<ul>
<li>如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树<br>
<img src="https://guyang233.github.io/post-images/1578905309119.png" alt="" loading="lazy"></li>
<li>完全二叉树除了具备普通二叉树的性质，自身也有一些独特的性质，比如说，n个结点的完全二叉树的深度为 ⌊log2n⌋+1</li>
</ul>
<pre><code>⌊log2n⌋ 表示取小于 log2n 的最大整数。例如，⌊log24⌋ = 2，而 ⌊log25⌋ 结果也是 2。
</code></pre>
<ul>
<li>对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右分布，，对于任意一个结点i，完全二叉树还有以下几个结论成立
<ul>
<li>当 i&gt;1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）</li>
<li>如果 2<em>i&gt;n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2</em>i。</li>
<li>如果 2<em>i+1&gt;n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2</em>i+1 。</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据结构-树存储结构]]></title>
        <id>https://guyang233.github.io/post/shu-ju-jie-gou-shu-cun-chu-jie-gou</id>
        <link href="https://guyang233.github.io/post/shu-ju-jie-gou-shu-cun-chu-jie-gou">
        </link>
        <updated>2020-01-13T07:12:41.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-简介">1、简介</h3>
<ul>
<li>一种非线性存储结构。存储的是具有一对多关系的数据元素集合<br>
<img src="https://guyang233.github.io/post-images/1578899735338.png" alt="" loading="lazy"></li>
</ul>
<h3 id="2-树的结点">2、树的结点</h3>
<ul>
<li>结点：使用树结构存储的每一个元素都被称为“结点”。</li>
<li>父结点（双亲结点）、子结点和兄弟结点：对于途中的A来说，A是B、C、D的父结点，也叫做双亲结点，B对于A来说就是子结点，B、C、D具有相同的父结点，所以他们之间为兄弟结点。</li>
<li>树（简称根结点）：每一个非空树都有且只有一个被称为根的结点，图中A结点为根结点。</li>
<li>叶子结点：如果结点没有任何的字结点，那么此结点被称为叶子结点（叶结点）</li>
</ul>
<h3 id="3-子树和空树">3、子树和空树</h3>
<ul>
<li>子树：上图来说，整棵树的根结点为A，如果单看B、E、F、K、L组成的部分来说，也是一棵树，而且结点B为这棵树的根结点。单个结点也是一棵树，只不过跟结点就是他本身，K、L都是树，而且整颗树都是子树。树也可以定义为根结点和若干颗子树构成的。</li>
<li>空树：如果集合本省为空，那么构成的树就被称为空树。空树中没有结点。</li>
<li>补充：在拥有同一个跟结点的子树之间不能相互有交集。否则破坏了树的结构。</li>
</ul>
<h3 id="4-结点的度和层次">4、结点的度和层次</h3>
<ul>
<li>对于一个结点，拥有的子树数（结点有多少分支）被称为结点的度（Degree），上图中A结点有三颗子树，所以A结点的度为3。一棵树的度是树内各结点的度的最大值，上图A结点的度的值最大，为3，所以整颗树的度就是3。</li>
<li>结点的层次：从一颗树的树根开始，树根所在的层为第一层，根的孩子结点所在的层为第二层，以此类推，上图的层次最大为4层，一棵树的深度（高度）是树中结点所在的最大层次，为4。</li>
<li>如果两个结点的父结点虽不相同，但是父结点处在同一层次上面，那么这两个结点就是堂兄弟的关系。</li>
</ul>
<h3 id="5-有序树和无序数">5、有序树和无序数</h3>
<ul>
<li>如果树中结点的子树从左看到右，谁在左边谁在右边是有规定的，那么这棵树成为有序树，反之则是无序树</li>
<li>在有序树中，一个结点的最左边的子树称为第一个孩子，最右边的成为最后一个孩子</li>
<li>上图：如果是一颗有序树，则结点B为根结点的子树为整棵树的第一个孩子，结点D为根结点的子树为最后一个孩子</li>
</ul>
<h3 id="6-森林">6、森林</h3>
<ul>
<li>由m（m&gt;=0）个互不相交的树组成的集合被称为森林，上图，B、C、D为根结点的三颗子树就可以被称为森林。</li>
<li>数还可用一个式子表达Tree=（root，F），root表示树的根结点，F为森林。</li>
</ul>
<h3 id="7-树的表示方法">7、树的表示方法</h3>
<figure data-type="image" tabindex="1"><img src="https://guyang233.github.io/post-images/1578901507284.png" alt="" loading="lazy"></figure>
<ul>
<li>左边是嵌套的集合形式，集合之间不能相交。</li>
<li>右边是凹入表示法。最长条为根结点，相同长度的表示为在同一层次</li>
<li>广义表：(A , ( B ( E ( K , L ) , F ) , C ( G ) , D ( H ( M ) , I , J ) ) )</li>
</ul>
<h3 id="8-总结">8、总结</h3>
<ul>
<li>树形存储结构类似于家族中的族谱，各个结点之间也同样可能具有父子、兄弟、表兄弟的关系</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IoC之Spring统一资源加载]]></title>
        <id>https://guyang233.github.io/post/ioc-zhi-spring-tong-yi-zi-yuan-jia-zai</id>
        <link href="https://guyang233.github.io/post/ioc-zhi-spring-tong-yi-zi-yuan-jia-zai">
        </link>
        <updated>2020-01-13T02:44:02.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-统一资源resource">1、统一资源：Resource</h3>
<ul>
<li>为Spring框架资源的抽象和访问接口，继承InputStreamSource接口，作为资源的统一抽象，Resource定义了一些通用的方法，由子类AbstractResource提供统一的默认实现。</li>
</ul>
<pre><code>  public interface Resource extends InputStreamSource {

	/**
	 * 资源是否存在
	 */
	boolean exists();

	/**
	 * 资源是否可读
	 */
	default boolean isReadable() {
		return true;
	}

	/**
	 * 资源所代表的句柄是否被一个 stream 打开了
	 */
	default boolean isOpen() {
		return false;
	}

	/**
	 * 是否为 File
	 */
	default boolean isFile() {
		return false;
	}

	/**
	 * 返回资源的 URL 的句柄
	 */
	URL getURL() throws IOException;

	/**
	 * 返回资源的 URI 的句柄
	 */
	URI getURI() throws IOException;

	/**
	 * 返回资源的 File 的句柄
	 */
	File getFile() throws IOException;

	/**
	 * 返回 ReadableByteChannel
	 */
	default ReadableByteChannel readableChannel() throws IOException {
		return java.nio.channels.Channels.newChannel(getInputStream());
	}

	/**
	 * 资源内容的长度
	 */
	long contentLength() throws IOException;

	/**
	 * 资源最后的修改时间
	 */
	long lastModified() throws IOException;

	/**
	 * 根据资源的相对路径创建新资源
	 */
	Resource createRelative(String relativePath) throws IOException;

	/**
	 * 资源的文件名
	 */
	@Nullable
	String getFilename();

	/**
	 * 资源的描述
	 */
	String getDescription();
  }
</code></pre>
<figure data-type="image" tabindex="1"><img src="https://guyang233.github.io/post-images/1578884649610.png" alt="" loading="lazy"></figure>
<ul>
<li>FileSystemResource:对java.io.File类型的资源封装。只要是跟File打交道的，基本上与FileSystemResource也可以打交道。支持文件和URL形式，实现WritableResource接口。从Spring5.0开始，FileSystemResource使用NIO2 API进行读/写交互</li>
<li>ByteArrayResource ：对字节数组提供的数据的封装，通过InputStream形式访问该类型的资源，该实现会根据字节数组的数据构造一个相应的ByteArrayInputStream</li>
<li>UrlResource ：对java.net.URL类型资源的封装，内部委派URl进行具体的资源操作</li>
<li>ClassPathResource：class path类型资源的封装，使用给定的ClassLoader或者给定的Class来加载资源</li>
<li>InputStreamResource：将给定的InputStream作为一种资源的Resource实现类。</li>
</ul>
<h4 id="12-abstractresource">1.2 AbstractResource</h4>
<ul>
<li>Resource接口的默认抽象实现，实现了Resource接口的大部分的公共实现。Resource接口中的重中之重，定义如下：</li>
</ul>
<pre><code>public abstract class AbstractResource implements Resource {

	/**
	 * 判断文件是否存在，若判断过程产生异常（因为会调用SecurityManager来判断），就关闭对应的流
	 */
	@Override
	public boolean exists() {
		try {
		  // 基于 File 进行判断
			return getFile().exists();
		}
		catch (IOException ex) {
			// Fall back to stream existence: can we open the stream?
			// 基于 InputStream 进行判断
			try {
				InputStream is = getInputStream();
				is.close();
				return true;
			} catch (Throwable isEx) {
				return false;
			}
		}
	}

	/**
	 * 直接返回true，表示可读
	 */
	@Override
	public boolean isReadable() {
		return true;
	}

	/**
	 * 直接返回 false，表示未被打开
	 */
	@Override
	public boolean isOpen() {
		return false;
	}

	/**
	 * 直接返回false，表示不为 File
	 */
	@Override
	public boolean isFile() {
		return false;
	}

	/**
	 * 抛出 FileNotFoundException 异常，交给子类实现
	 */
	@Override
	public URL getURL() throws IOException {
		throw new FileNotFoundException(getDescription() + &quot; cannot be resolved to URL&quot;);

	}

	/**
	 * 基于 getURL() 返回的 URL 构建 URI
	 */
	@Override
	public URI getURI() throws IOException {
		URL url = getURL();
		try {
			return ResourceUtils.toURI(url);
		} catch (URISyntaxException ex) {
			throw new NestedIOException(&quot;Invalid URI [&quot; + url + &quot;]&quot;, ex);
		}
	}

	/**
	 * 抛出 FileNotFoundException 异常，交给子类实现
	 */
	@Override
	public File getFile() throws IOException {
		throw new FileNotFoundException(getDescription() + &quot; cannot be resolved to absolute file path&quot;);
	}

	/**
	 * 根据 getInputStream() 的返回结果构建 ReadableByteChannel
	 */
	@Override
	public ReadableByteChannel readableChannel() throws IOException {
		return Channels.newChannel(getInputStream());
	}

	/**
	 * 获取资源的长度
	 *
	 * 这个资源内容长度实际就是资源的字节长度，通过全部读取一遍来判断
	 */
	@Override
	public long contentLength() throws IOException {
		InputStream is = getInputStream();
		try {
			long size = 0;
			byte[] buf = new byte[255]; // 每次最多读取 255 字节
			int read;
			while ((read = is.read(buf)) != -1) {
				size += read;
			}
			return size;
		} finally {
			try {
				is.close();
			} catch (IOException ex) {
			}
		}
	}

	/**
	 * 返回资源最后的修改时间
	 */
	@Override
	public long lastModified() throws IOException {
		long lastModified = getFileForLastModifiedCheck().lastModified();
		if (lastModified == 0L) {
			throw new FileNotFoundException(getDescription() +
					&quot; cannot be resolved in the file system for resolving its last-modified timestamp&quot;);
		}
		return lastModified;
	}

	protected File getFileForLastModifiedCheck() throws IOException {
		return getFile();
	}

	/**
	 * 抛出 FileNotFoundException 异常，交给子类实现
	 */
	@Override
	public Resource createRelative(String relativePath) throws IOException {
		throw new FileNotFoundException(&quot;Cannot create a relative resource for &quot; + getDescription());
	}

	/**
	 * 获取资源名称，默认返回 null ，交给子类实现
	 */
	@Override
	@Nullable
	public String getFilename() {
		return null;
	}

	/**
	 * 返回资源的描述
	 */
	@Override
	public String toString() {
		return getDescription();
	}

	@Override
	public boolean equals(Object obj) {
		return (obj == this ||
			(obj instanceof Resource &amp;&amp; ((Resource) obj).getDescription().equals(getDescription())));
	}

	@Override
	public int hashCode() {
		return getDescription().hashCode();
	}

}
</code></pre>
<ul>
<li>如果我们想实现自定义的Resource，不要实现Resource接口，而应该继承AbstractResource抽象类，根据当前的具体资源特性覆盖对应的方法即可</li>
</ul>
<h4 id="13-其他子类">1.3 其他子类</h4>
<ul>
<li>FileSystemResource</li>
<li>ByteArrayResource</li>
<li>UrlResource</li>
<li>ClassPathResource</li>
<li>InputStreamResource</li>
</ul>
<h3 id="2-统一资源定位resourceloader">2、统一资源定位：ResourceLoader</h3>
<ul>
<li>Spring将资源的定义和资源的加载区分开了，Resource定义了统一的资源，那么资源的加载则由ResourceLoader来统一定义。</li>
<li>ResourceLoader为pring资源的统一加载抽象，具体的资源加载则由相应的实现类来完成，所以我们可以将ResourceLoader作为统一资源定位器。ResourceLoader，定义资源加载器，主要应用于根据给的资源文件地址，返回相应的Resource</li>
</ul>
<pre><code>public interface ResourceLoader {

// CLASSPATH URL 前缀。默认为：&quot;classpath:&quot;
	String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX; 

	Resource getResource(String location);

	ClassLoader getClassLoader();

}
</code></pre>
<ul>
<li>#getResource(String location)方法
<ul>
<li>根据资源提供的位置离加载资源，不确保Resource一定存在，需要调用Resource.exist()来判断资源是否存在。支持一下方法来加载：
<ul>
<li>支持绝对路径：file:C:/test.dat&quot;.</li>
<li>伪路径：&quot;classpath:test.dat&quot;.</li>
<li>支持相对路径：&quot;WEB-INF/test.dat&quot;.</li>
</ul>
</li>
<li>该方法主要是在其子类DefaultResourceLoader中实现。具体过程在分析DefaultResourceLoader时详细说明</li>
</ul>
</li>
<li>#getClassLoader()方法
<ul>
<li>返回ClassLoader实例，对于想要获取ResourceLoader使用的ClassLoader用户来说，可以直接调用该方法来获取，在分析Resource是，提到了一个ClassPathResource，这个类是可以根据指定的CLassLoader来加载资源的</li>
</ul>
</li>
</ul>
<h4 id="21-子类结构">2.1、子类结构</h4>
<ul>
<li>作为Spring统一的资源加载器，提供了统一的抽象，具体IDE实现规则有相应的子类来负责实现，结构的类图<br>
<img src="https://guyang233.github.io/post-images/1578971511318.png" alt="" loading="lazy"></li>
</ul>
<h5 id="211-defaultresourceloader">2.1.1 DefaultResourceLoader</h5>
<ul>
<li>与AbstractResource相似，是ResourceLoader的默认实现</li>
<li>构造函数：接收ClassLoader作为构造函数的参数，或者使用不带参数的构造函数
<ul>
<li>在使用不带参数的构造函数的时候，使用额ClassLoader为默认的ClassLoader，一般都是Thread.currentThread().getContextClassLoader();</li>
<li>使用带参数的构造函数时，可以通过 ClassUtils#getDefaultClassLoader()来获取。</li>
</ul>
</li>
</ul>
<pre><code>@Nullable
private ClassLoader classLoader;
// 无参构造函数
public DefaultResourceLoader() { 
	this.classLoader = ClassUtils.getDefaultClassLoader();
}
// 带 ClassLoader 参数的构造函数
public DefaultResourceLoader(@Nullable ClassLoader classLoader) { 
	this.classLoader = classLoader;
}

public void setClassLoader(@Nullable ClassLoader classLoader) {
	this.classLoader = classLoader;
}

@Override
@Nullable
public ClassLoader getClassLoader() {
	return (this.classLoader != null ? this.classLoader : ClassUtils.getDefaultClassLoader());
}
另外也可以调用#setClassLoader()方法进行后续设置
</code></pre>
<h5 id="212-getresource方法">2.1.2 getResource方法</h5>
<ul>
<li>ResourceLoader中最核心的方法为#getResource(String location)</li>
</ul>
<pre><code>	@Override
	public Resource getResource(String location) {
		Assert.notNull(location, &quot;Location must not be null&quot;);

		//首先遍历protocolResolvers set集合，初始为空的
		for (ProtocolResolver protocolResolver : this.protocolResolvers) {
			Resource resource = protocolResolver.resolve(location, this);
			if (resource != null) {
				return resource;
			}
		}
		//判断路径是否以“/”开头，是的话采用路径加载Resource
		if (location.startsWith(&quot;/&quot;)) {
			return getResourceByPath(location);
		}
		//是否是classpath路径，是的话加载classpath资源
		else if (location.startsWith(CLASSPATH_URL_PREFIX)) {
			return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());
		}
		else {
			//判断是否为文件URL， 是的话就返回FileUrlResource， 否则返回UrlResource
			try {
				// Try to parse the location as a URL...
				URL url = new URL(location);
				return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));
			}
			catch (MalformedURLException ex) {
				//最后，返回 ClassPathContextResource 类型的资源
				// No URL -&gt; resolve as resource path.
				return getResourceByPath(location);
			}
		}
	}
</code></pre>
<ul>
<li>首先，通过ProtocolResolver来加载资源，成功返回Resource</li>
<li>其次，若location以&quot;/&quot;开头，则调用#getResourceByPath()方法，构造ClassPathContextResource类型资源并返回</li>
</ul>
<pre><code>	protected Resource getResourceByPath(String path) {
		return new ClassPathContextResource(path, getClassLoader());
	}
</code></pre>
<ul>
<li>再次，判断path是否以classpath:开头，是的话构造ClassPathResource类型资源返回在构造该资源时，通过#getClassLoader()获取当前的ClassLoader</li>
<li>然后构造URL类型的资源，尝试通过它来对资源进行定位，如果没有抛出MalformedURLException异常的话，判断是是否为文件URL，如果是的话构造FileUrlResource，如果不是的话构造UrlResource类型的资源。</li>
<li>最后，如果抛出MalformedURLException异常，就调用#getResourceByPath方法来加载资源。</li>
</ul>
<h5 id="212-protocolresolver">2.1.2 ProtocolResolver</h5>
<ul>
<li>ProtocolResolver，用户自定义协议资源解决策略，作为DefaultResourceLoader的SPI：允许用户自定义资源加载协议，而不需要继承ResourceLoader的子类</li>
<li>在介绍Resource的时候提到如果实现自定义的Resource，我们只需要继承AbstractResource即可，但是有了ProtocolResolver后，我们不需要直接继承DefaultResourceLoader，改为实现ProtocolResolver接口也可以实现自定义的ResourceLoader</li>
<li>ProtocolResolver只有一个方法</li>
</ul>
<pre><code>	/**
	 * 使用指定的ResourceLoader来加载location的Resource
	 * 
	 * 
	 * Resolve the given location against the given resource loader
	 * if this implementation's protocol matches.
	 * @param location the user-specified resource location
	 * @param resourceLoader the associated resource loader
	 * @return a corresponding {@code Resource} handle if the given location
	 * matches this resolver's protocol, or {@code null} otherwise
	 */
	@Nullable
	Resource resolve(String location, ResourceLoader resourceLoader);
</code></pre>
<ul>
<li>在Spring没有该接口的实现类，需要用户自定义，自定义的Resolver想要加入Spring体系，调用DefaultResourceLoader.addProtocolResolver()方法就行</li>
</ul>
<pre><code>/**
	 * Register the given resolver with this resource loader, allowing for
	 * additional protocols to be handled.
	 * &lt;p&gt;Any such resolver will be invoked ahead of this loader's standard
	 * resolution rules. It may therefore also override any default rules.
	 * @since 4.3
	 * @see #getProtocolResolvers()
	 */
	public void addProtocolResolver(ProtocolResolver resolver) {
		Assert.notNull(resolver, &quot;ProtocolResolver must not be null&quot;);
		this.protocolResolvers.add(resolver);
	}
</code></pre>
<h4 id="22-filesystemresourceloader">2.2 FileSystemResourceLoader</h4>
<ul>
<li>DefaultResourceLoader对于#getResourceByPath(String)处理的不是很恰当，这个时候我们可以使用FileSystemResourceLoader，他继承了DefaultResourceLoader，并且复写了getResourceByPath，使文件系统加载资源并以FileSystemContextResource类型返回，这样就得到了想要的资源类型：</li>
</ul>
<pre><code>	@Override
	protected Resource getResourceByPath(String path) {
		if (path.startsWith(&quot;/&quot;)) {
			path = path.substring(1);
		}
		return new FileSystemContextResource(path);
	}
</code></pre>
<h5 id="221-filesystemcontextresource">2.2.1 FileSystemContextResource</h5>
<ul>
<li>FileSystemContextResource, 是FileSystemResourceLoader的内部类，继承了FileSystemResource，实现ContextResource接口</li>
</ul>
<pre><code>	/**
	 * FileSystemResource that explicitly expresses a context-relative path
	 * through implementing the ContextResource interface.
	 */
	private static class FileSystemContextResource extends FileSystemResource implements ContextResource {

		public FileSystemContextResource(String path) {
			super(path);
		}

		@Override
		public String getPathWithinContext() {
			return getPath();
		}
	}
</code></pre>
<ul>
<li>在构造器中，调用的是FileSystemResource的构造函数来构造FileSystemResource的</li>
<li>为什么要有FileSystemContextResource类的原因是，实现ContextResource接口， 并实现对应的#getPathWithinContext()接口方法</li>
</ul>
<h4 id="23-classrelativeresourceloader">2.3 ClassRelativeResourceLoader</h4>
<ul>
<li>ClassRelativeResourceLoader，是DefaultResourceLoader的另一个子类的实现，和 FileSystemResourceLoader 类似，在实现代码的结构上类似，也是覆写 #getResourceByPath(String path) 方法，并返回其对应的 ClassRelativeContextResource 的资源类型。</li>
<li>ClassRelativeResourceLoader 扩展的功能是，可以根据给定的 class 所在包或者所在包的子包下加载资源。</li>
</ul>
<h4 id="24-resourcepatternresolver">2.4 ResourcePatternResolver</h4>
<ul>
<li>ResourceLoader的#getResource方法，每次只能根据location来返回一个Resource，当需要加载多个资源的时候，我们除了多次调用#getResource方法外，没有别的办法。ResourcePatternResolver是ResourceLoader 的扩展，支持根据指定的资源路径匹配模式每次返回多个Resource实例。</li>
</ul>
<pre><code>public interface ResourcePatternResolver extends ResourceLoader {

	/**
	 * Pseudo URL prefix for all matching resources from the class path: &quot;classpath*:&quot;
	 * This differs from ResourceLoader's classpath URL prefix in that it
	 * retrieves all matching resources for a given name (e.g. &quot;/beans.xml&quot;),
	 * for example in the root of all deployed JAR files.
	 * @see org.springframework.core.io.ResourceLoader#CLASSPATH_URL_PREFIX
	 */
	String CLASSPATH_ALL_URL_PREFIX = &quot;classpath*:&quot;;

	/**
	 * Resolve the given location pattern into Resource objects.
	 * &lt;p&gt;Overlapping resource entries that point to the same physical
	 * resource should be avoided, as far as possible. The result should
	 * have set semantics.
	 * @param locationPattern the location pattern to resolve
	 * @return the corresponding Resource objects
	 * @throws IOException in case of I/O errors
	 */
	Resource[] getResources(String locationPattern) throws IOException;

}
</code></pre>
<ul>
<li>ResourcePatternResolver在ResourceLoader的基础上增加了#getResources方法，支持根绝路径匹配模式返回多个Resource实例</li>
<li>同时，也新增了一种新的协议前缀， &quot;classpath*:&quot;，该协议前缀由其子类负责实现</li>
</ul>
<h4 id="25-pathmatchingresourcepatternresolver">2.5 PathMatchingResourcePatternResolver</h4>
<ul>
<li>PathMatchingResourcePatternResolver， 是ResourcePatternResovler最常用的子类，除了支持ResourceLoader和ResourcePatternResolver 新增的 &quot;classpath*:&quot; 前缀外，还支持 Ant 风格的路径匹配模式（类似于 &quot;**/*.xml&quot;）</li>
</ul>
<h5 id="251-构造函数">2.5.1 构造函数</h5>
<pre><code>/**
 * 内置的 ResourceLoader 资源定位器
 */
private final ResourceLoader resourceLoader;
/**
 * Ant 路径匹配器
 */
private PathMatcher pathMatcher = new AntPathMatcher();

public PathMatchingResourcePatternResolver() {
	this.resourceLoader = new DefaultResourceLoader();
}

public PathMatchingResourcePatternResolver(ResourceLoader resourceLoader) {
	Assert.notNull(resourceLoader, &quot;ResourceLoader must not be null&quot;);
	this.resourceLoader = resourceLoader;
}

public PathMatchingResourcePatternResolver(@Nullable ClassLoader classLoader) {
	this.resourceLoader = new DefaultResourceLoader(classLoader);
}
</code></pre>
<ul>
<li>PathMatchingResourcePatternResolver在实例化的时候，可以指定一个ResourceLoader，如果没有指定的话，会在内部构造一个DefaultResourceLoader</li>
<li>pathMatcher 属性，默认为 AntPathMatcher 对象，用于支持 Ant 类型的路径匹配。</li>
</ul>
<h5 id="252-getresource">2.5.2 getResource</h5>
<pre><code>	@Override
	public Resource getResource(String location) {
		return getResourceLoader().getResource(location);
	}

    public ResourceLoader getResourceLoader() {
		return this.resourceLoader;
	}
</code></pre>
<ul>
<li>这个方法直接委托给响应的ResourceLoader来实现，所以我们如果在实例化PathMatchingResourcePatternResolver的时候，如果未指定ResourceLoader参数的情况下，在加载资源的时候，电泳的是DefaultResourceLoader的#getResource的过程</li>
</ul>
<h5 id="253-getresources">2.5.3 getResources</h5>
<pre><code>	@Override
	public Resource[] getResources(String locationPattern) throws IOException {
		Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;);
		//以classpath*: 开头
		if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) {
			// a class path resource (multiple resources for same name possible)
			//路径包含通配符
			if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) {
				// a class path resource pattern
				return findPathMatchingResources(locationPattern);
			}
			//路径不包含通配符
			else {
				// all class path resources with the given name
				return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));
			}
		}
		//不以classpath*: 开头
		else {
			// Generally only look for a pattern after a prefix here,
			// and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol.
			int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ? locationPattern.indexOf(&quot;*/&quot;) + 1 :
					locationPattern.indexOf(':') + 1);
			//包含通配符
			if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) {
				// a file pattern
				return findPathMatchingResources(locationPattern);
			}
			//不包含通配符
			else {
				// a single resource with the given name
				return new Resource[] {getResourceLoader().getResource(locationPattern)};
			}
		}
	}
</code></pre>
<ul>
<li>处理逻辑
<ul>
<li>非“classpath*:”开头，且不包含通配符的，直接委托给相应的ResourceLoader来实现</li>
<li>其他情况，调用#findPathMatchingResources和#findAllClassPathResources来返回多个Resource</li>
</ul>
</li>
</ul>
<h5 id="254-findallclasspathresources">2.5.4 findAllClassPathResources</h5>
<ul>
<li>当locationPattern以“classpath*:”开头，但是不包含通配符，则调用#findAllClassPathResources方法加载资源，返回classes路径下和所有jar包中的所有相匹配的资源</li>
</ul>
<pre><code>protected Resource[] findAllClassPathResources(String location) throws IOException {
	String path = location;
	// 去除首个 /
	if (path.startsWith(&quot;/&quot;)) {
		path = path.substring(1);
	}
	// 真正执行加载所有 classpath 资源
	Set&lt;Resource&gt; result = doFindAllClassPathResources(path);
	if (logger.isTraceEnabled()) {
		logger.trace(&quot;Resolved classpath location [&quot; + location + &quot;] to resources &quot; + result);
	}
	// 转换成 Resource 数组返回
	return result.toArray(new Resource[0]);
}
</code></pre>
<ul>
<li>真正执行加载的是#doFindAllClassPathResources</li>
</ul>
<pre><code>protected Set&lt;Resource&gt; doFindAllClassPathResources(String path) throws IOException {
		Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16);
		ClassLoader cl = getClassLoader();
		//根据ClassLoader加载路径下的所有资源
		Enumeration&lt;URL&gt; resourceUrls = (cl != null ? cl.getResources(path) : ClassLoader.getSystemResources(path));
		while (resourceUrls.hasMoreElements()) {
			URL url = resourceUrls.nextElement();
			//将URL转为UrlResource
			result.add(convertClassLoaderURL(url));
		}
		if (&quot;&quot;.equals(path)) {
			// The above result is likely to be incomplete, i.e. only containing file system references.
			// We need to have pointers to each of the jar files on the classpath as well...
			//加载路径下面的所有Jar包
			addAllClassLoaderJarRoots(cl, result);
		}
		return result;
	}
</code></pre>
<ul>
<li>根据ClassLoader加载路径下的所有资源，在加载资源的过程中，如果在构造PathMatchingResourcePatternResolver的时候传入了ClassLoader，那么调用ClassLoader的getResources方法，否则调用ClassLoader#getSystemResources</li>
<li>ClassLoader#getResources方法：</li>
</ul>
<pre><code>
</code></pre>
]]></content>
    </entry>
</feed>